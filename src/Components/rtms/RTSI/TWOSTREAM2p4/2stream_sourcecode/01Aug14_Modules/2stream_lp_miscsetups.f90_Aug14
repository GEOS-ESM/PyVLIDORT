! ###########################################################
! #                                                         #
! #             THE TWOSTREAM LIDORT MODEL                  #
! #                                                         #
! #      (LInearized Discrete Ordinate Radiative Transfer)  #
! #       --         -        -        -         -          #
! #                                                         #
! ##########################################################

! ###########################################################
! #                                                         #
! #  Authors :      Robert. J. D. Spurr (1)                 #
! #                 Vijay Natraj        (2)                 #
! #                                                         #
! #  Address (1) :     RT Solutions, Inc.                   #
! #                    9 Channing Street                    #
! #                    Cambridge, MA 02138, USA             #
! #  Tel:             (617) 492 1183                        #
! #  Email :           rtsolutions@verizon.net              #
! #                                                         #
! #  Address (2) :     CalTech                              #
! #                    Department of Planetary Sciences     #
! #                    1200 East California Boulevard       #
! #                    Pasadena, CA 91125                   #
! #  Tel:             (626) 395 6962                        #
! #  Email :           vijay@gps.caltech.edu                #
! #                                                         #
! #  Version 1.0-1.3 :                                      #
! #     Mark 1: October  2010                               #
! #     Mark 2: May      2011, with BRDFs                   #
! #     Mark 3: October  2011, with Thermal sources         #
! #                                                         #
! #  Version 2.0-2.1 :                                      #
! #     Mark 4: November 2012, LCS/LPS Split, Fixed Arrays  #
! #     Mark 5: December 2012, Observation Geometry option  #
! #                                                         #
! #  Version 2.2-2.3 :                                      #
! #     Mark 6: July     2013, Level outputs + control      #
! #     Mark 7: December 2013, Flux outputs  + control      #
! #     Mark 8: January  2014, Surface Leaving + control    #
! #     Mark 9: June     2014, Inverse Pentadiagonal        #
! #                                                         #
! ###########################################################

! #############################################################
! #                                                           #
! #   This Version of LIDORT-2STREAM comes with a GNU-style   #
! #   license. Please read the license carefully.             #
! #                                                           #
! #############################################################

! ###############################################################
! #                                                             #
! # Subroutines in this Module                                  #
! #                                                             #
! #              TWOSTREAM_LP_QSPREP                            #
! #              TWOSTREAM_LP_EMULTMASTER                       #
! #                TWOSTREAM_LP_EMULT_UP                        #
! #                TWOSTREAM_LP_EMULT_DN                        #
! #              TWOSTREAM_LP_EMULTMASTER_OBSGEO                #
! #                TWOSTREAM_LP_EMULT_OG_UP                     #
! #                TWOSTREAM_LP_EMULT_OG_DN                     #
! #                                                             #
! ###############################################################

module twostream_lp_miscsetups_m

private
PUBLIC TWOSTREAM_LP_QSPREP, TWOSTREAM_LP_EMULTMASTER, &
                            TWOSTREAM_LP_EMULTMASTER_OBSGEO

contains

SUBROUTINE TWOSTREAM_LP_QSPREP &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,  & ! Dimensions
         DO_POSTPROCESSING, NLAYERS, NBEAMS, N_USER_STREAMS,   & ! Inputs
         DO_PLANE_PARALLEL,LAYER_VARY_FLAG, LAYER_VARY_NUMBER, & ! Inputs
         DELTAU_VERT, L_DELTAU_VERT, CHAPMAN_FACTORS,          & ! Inputs
         USER_STREAMS, T_DELT_USERM, LAYER_PIS_CUTOFF,         & ! Inputs
         AVERAGE_SECANT, T_DELT_MUBAR,                         & ! Inputs
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                  & ! output
         LP_T_DELT_MUBAR, L_T_DELT_USERM )                       ! output

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  Inputs
!  ------

!  Dimensions

      INTEGER, INTENT(IN)        :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!    !@@ Add Post-processing flag, 11/5/13

      LOGICAL, intent(in)       :: DO_POSTPROCESSING  !@@

!  Numbers

      INTEGER, INTENT(IN)        :: NLAYERS, NBEAMS, N_USER_STREAMS

!  BEAM control

      LOGICAL, INTENT(IN)        :: DO_PLANE_PARALLEL

!  Linearization control

      LOGICAL, INTENT(IN)        :: LAYER_VARY_FLAG   ( MAXLAYERS )
      INTEGER, INTENT(IN)        :: LAYER_VARY_NUMBER ( MAXLAYERS )

!  Layer optical thickness and linearization

      REAL(kind=dp), INTENT(IN)  :: DELTAU_VERT   ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_DELTAU_VERT ( MAXLAYERS, MAX_ATMOSWFS )

!  Chapman factors

      REAL(kind=dp), INTENT(IN)  :: CHAPMAN_FACTORS ( MAXLAYERS, MAXLAYERS, MAXBEAMS )

!  User streams

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )

!  Transmittance factors for user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS )

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)        :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  Average-secant and transittance factors for solar beams.

      REAL(kind=dp), INTENT(IN)  :: AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS )

!  Transmittance factors for average secant stream

      REAL(kind=dp), INTENT(IN)  :: T_DELT_MUBAR ( MAXLAYERS, MAXBEAMS )

!  Output
!  ======

!   Linearized Average-secant and initial transittance factors

      REAL(kind=dp), INTENT(OUT) :: LP_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(OUT) :: LP_INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )

!  Transmittance factors for average secant stream

      REAL(kind=dp), INTENT(OUT) :: LP_T_DELT_MUBAR   ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )

!  Transmittance factors for user-defined stream angles

      REAL(kind=dp), INTENT(OUT) :: L_T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS )

!  Local variables
!  ---------------

      INTEGER                  :: N, K, IB, Q, UM
      REAL(kind=dp), PARAMETER :: MAX_TAU_PATH = 88.0d0
      REAL(kind=dp)            :: VAR, WDEL, RHO, TRANS, CF, DELT, LAMDA, FAC

!  linearization of Initial transmittances
!  =======================================

!         Use Logarithmic derivative !!!!
!         Reason: avoids exceptions if INITIAL_TRANS underflows

!  Profile linearization

      DO IB = 1, NBEAMS
        DO N = 1, NLAYERS
          IF  (N.LE.LAYER_PIS_CUTOFF(IB) ) THEN
            DO Q = 1, LAYER_VARY_NUMBER(N)
              LP_INITIAL_TRANS(N,IB,N,Q) = 0.0d0
            ENDDO
            IF ( N .GT. 1 ) THEN
              DO K = 1, N-1
                DO Q = 1, LAYER_VARY_NUMBER(K)
                  CF = CHAPMAN_FACTORS(N-1,K,IB)
                  FAC = - L_DELTAU_VERT(K,Q) * CF
!                  FAC = FAC * INITIAL_TRANS(N,IB)   ! Non-log Derivative
                  LP_INITIAL_TRANS(N,IB,K,Q) = FAC
                ENDDO
              ENDDO
            ENDIF
          ELSE
            DO K = 1, N
              DO Q = 1, LAYER_VARY_NUMBER(K)
                LP_INITIAL_TRANS(N,IB,K,Q) = 0.0d0
              ENDDO
            ENDDO
          ENDIF
        ENDDO
      ENDDO

!  linearization of average secants for pseudo-spherical case
!  ==========================================================

!   (average secant = 1/mu-0 = constant for plane parallel)

      IF ( .NOT. DO_PLANE_PARALLEL ) THEN

        DO IB = 1, NBEAMS
          DO N = 1, NLAYERS
            IF ( N .EQ. 1 ) THEN
              DO Q = 1, LAYER_VARY_NUMBER(N)
                LP_AVERAGE_SECANT(N,IB,N,Q) = 0.0D0
              ENDDO
            ELSE
              IF  (N.LE.LAYER_PIS_CUTOFF(IB) ) THEN
                DELT  = DELTAU_VERT(N)
                LAMDA = AVERAGE_SECANT(N,IB)
                FAC   = ( CHAPMAN_FACTORS(N,N,IB) - LAMDA ) / DELT
                DO Q = 1, LAYER_VARY_NUMBER(N)
                  LP_AVERAGE_SECANT(N,IB,N,Q) = L_DELTAU_VERT(N,Q) * FAC
                ENDDO
                DO K = 1, N-1
                  FAC = ( CHAPMAN_FACTORS(N,K,IB) - &
                          CHAPMAN_FACTORS(N-1,K,IB) ) / DELT
                  DO Q = 1, LAYER_VARY_NUMBER(K)
                    LP_AVERAGE_SECANT(N,IB,K,Q) = &
                        L_DELTAU_VERT(K,Q) * FAC
                  ENDDO
                ENDDO
              ELSE
                DO K = 1, N
                  DO Q = 1, LAYER_VARY_NUMBER(K)
! @@ Bug 04 Jun 12, Order of indices reversed
!                    LP_AVERAGE_SECANT(N,K,IB,Q) = 0.0D0
                    LP_AVERAGE_SECANT(N,IB,K,Q) = 0.0D0
                  ENDDO
                ENDDO
              ENDIF
            ENDIF
          ENDDO
        ENDDO

!  End pseudo-spherical clause
!  Plane parallel (safety first)

      ELSE

        DO IB = 1, NBEAMS
          DO N = 1, NLAYERS
            DO K = 1, NLAYERS
              DO Q = 1, MAX_ATMOSWFS
                LP_AVERAGE_SECANT(N,IB,K,Q) = 0.0D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO

      ENDIF

!  debug
!      do N = 1, nlayers
!       write(*,'(2i3,1p3e20.10)')n,1,(l_average_secant(n,1,k,1),k=1,n)
!       write(*,'(2i3,1p3e20.10)')n,2,(l_average_secant(n,1,k,2),k=1,n)
!      enddo
!      pause
!  debug
!      do N = 1, nlayers
!       write(*,'(a,i3,1p2e20.10)')'lin',n,l_initial_trans(n,1,0,1), &
!                   l_average_secant(n,1,0,1)
!      enddo

!  Linearization of Whole layer Transmittance factors
!  ==================================================

      DO IB = 1, NBEAMS
        DO N = 1, NLAYERS

         WDEL  = T_DELT_MUBAR(N,IB)
         LAMDA = AVERAGE_SECANT(N,IB)
         VAR   = - DELTAU_VERT(N) * WDEL
         FAC   = - WDEL * AVERAGE_SECANT(N,IB)
 
!  Pseudo-spherical

         IF ( .NOT. DO_PLANE_PARALLEL ) THEN

          IF ( N .EQ. 1 ) THEN
            DO Q = 1, LAYER_VARY_NUMBER(N)
              LP_T_DELT_MUBAR(N,IB,N,Q) = FAC * L_DELTAU_VERT(N,Q)
            ENDDO
          ELSE
            IF  ( N.LE.LAYER_PIS_CUTOFF(IB) ) THEN
              DO Q = 1, LAYER_VARY_NUMBER(N)
                RHO = LP_AVERAGE_SECANT(N,IB,N,Q)
                LP_T_DELT_MUBAR(N,IB,N,Q) = L_DELTAU_VERT(N,Q) * FAC &
                                          + VAR * RHO
              ENDDO
              DO K = 1, N-1
                DO Q = 1, LAYER_VARY_NUMBER(K)
                  RHO = LP_AVERAGE_SECANT(N,IB,K,Q)
                  LP_T_DELT_MUBAR(N,IB,K,Q) = VAR * RHO
                ENDDO
              ENDDO
            ELSE
              DO K = 1, N
                DO Q = 1, LAYER_VARY_NUMBER(K)
                  LP_T_DELT_MUBAR(N,IB,K,Q) = 0.0D0
                ENDDO
              ENDDO
            ENDIF
          ENDIF

!  Plane-parallel

         ELSE IF ( DO_PLANE_PARALLEL ) THEN

          IF  (N.LE.LAYER_PIS_CUTOFF(IB) ) THEN
            DO Q = 1, LAYER_VARY_NUMBER(N)
              LP_T_DELT_MUBAR(N,IB,N,Q) = FAC * L_DELTAU_VERT(N,Q)
            ENDDO
            DO K = 1, N-1
              DO Q = 1, LAYER_VARY_NUMBER(K)
                LP_T_DELT_MUBAR(N,IB,K,Q) = 0.0D0
              ENDDO
            ENDDO
          ELSE
            DO K = 1, N
              DO Q = 1, LAYER_VARY_NUMBER(K)
                LP_T_DELT_MUBAR(N,IB,K,Q) = 0.0D0
              ENDDO
            ENDDO
          ENDIF

         ENDIF

!  end layer and beam loops

        ENDDO
      ENDDO

!  Linearization of Transmittance factors for User Streams
!  -------------------------------------------------------

!    !@@ Add Post-processing control, 11/5/13

      IF ( DO_POSTPROCESSING ) THEN
        DO N = 1, NLAYERS
          IF ( LAYER_VARY_FLAG(N) ) THEN
            DO UM = 1, N_USER_STREAMS
              TRANS = T_DELT_USERM(N,UM) / USER_STREAMS(UM)
              DO Q = 1, LAYER_VARY_NUMBER(N)
                L_T_DELT_USERM(N,UM,Q) = - TRANS * L_DELTAU_VERT(N,Q)
              ENDDO
            ENDDO
          ENDIF
        ENDDO
      ENDIF

!  FInish

      RETURN
END SUBROUTINE TWOSTREAM_LP_QSPREP

!

SUBROUTINE TWOSTREAM_LP_EMULTMASTER &
          ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,  & ! Dimensions
            DO_UPWELLING, DO_DNWELLING, DO_PLANE_PARALLEL,        & ! inputs
            NLAYERS, NBEAMS, N_USER_STREAMS,                      & ! inputs
            LAYER_VARY_FLAG, LAYER_VARY_NUMBER,                   & ! inputs
            DELTAU_VERT, L_DELTAU_VERT,                           & ! inputs
            USER_STREAMS, T_DELT_MUBAR, T_DELT_USERM,             & ! inputs
            ITRANS_USERM, LAYER_PIS_CUTOFF, INITIAL_TRANS,        & ! inputs
            LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                  & ! inputs
            LP_T_DELT_MUBAR,  L_T_DELT_USERM,                     & ! inputs
            SIGMA_M, SIGMA_P, EMULT_HOPRULE, EMULT_UP, EMULT_DN,  & ! inputs
            LP_EMULT_UP, LP_EMULT_DN )                              ! output

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  Prepare multipliers for the Beam source terms

!  Dimensions

      INTEGER, INTENT(IN)        :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Control

      LOGICAL, INTENT(IN)        :: DO_UPWELLING, DO_DNWELLING

!  BEAM control

      LOGICAL, INTENT(IN)        :: DO_PLANE_PARALLEL

!  Numbers

      INTEGER, INTENT(IN)        :: NLAYERS, NBEAMS, N_USER_STREAMS

!  Linearization control

      LOGICAL, INTENT(IN)        :: LAYER_VARY_FLAG   ( MAXLAYERS )
      INTEGER, INTENT(IN)        :: LAYER_VARY_NUMBER ( MAXLAYERS )

!  Layer optical thickness and linearization

      REAL(kind=dp), INTENT(IN)  :: DELTAU_VERT   ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_DELTAU_VERT ( MAXLAYERS, MAX_ATMOSWFS )

!  User streams

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )

!  Transmittance factors for average secant stream

      REAL(kind=dp), INTENT(IN)  :: T_DELT_MUBAR ( MAXLAYERS, MAXBEAMS )

!  Transmittance factors for user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS )

!  initial transittance factors for solar beams.

      REAL(kind=dp), INTENT(IN)  :: ITRANS_USERM   ( MAXLAYERS, MAX_USER_STREAMS, MAXBEAMS )
      REAL(kind=dp), INTENT(IN)  :: INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS )

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)        :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  Linearizations of Transmittance factors 

      REAL(kind=dp), INTENT(IN)  :: LP_INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_T_DELT_MUBAR   ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS )

!  coefficient functions for user-defined angles

      REAL(kind=dp), INTENT(IN)  :: SIGMA_P(MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)
      REAL(kind=dp), INTENT(IN)  :: SIGMA_M(MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)
      
!  L'Hopital's rule logical variables

      LOGICAL, INTENT(IN)        :: EMULT_HOPRULE (MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)

!  forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(IN)  :: EMULT_UP (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)
      REAL(kind=dp), INTENT(IN)  :: EMULT_DN (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)

!  Output
!  ======

!  Linearized forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(OUT) :: LP_EMULT_UP (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(OUT) :: LP_EMULT_DN (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  local variables
!  ---------------

      INTEGER        ::  N, K

!  Upwelling
!  =========

      IF ( DO_UPWELLING ) THEN

!    Profiles:  loop over all varying layers K such that K </= N 

         DO N = 1, NLAYERS
            DO K = 1, N
              CALL TWOSTREAM_LP_EMULT_UP &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,& ! Dimensions
         NBEAMS, N_USER_STREAMS,                             & ! input
         LAYER_VARY_FLAG(K), N, K, LAYER_VARY_NUMBER(K),     & ! input
         DO_PLANE_PARALLEL, LAYER_PIS_CUTOFF, ITRANS_USERM,  & ! input
         T_DELT_MUBAR, T_DELT_USERM, SIGMA_P, EMULT_UP,      & ! input
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                & ! input
         LP_T_DELT_MUBAR,  L_T_DELT_USERM,                   & ! input
         LP_EMULT_UP )                                         ! in/out
            ENDDO
         ENDDO

!  debug
!          DO N = 1, NLAYERS
!            write(56,'(i3,1p3e24.12)')n,(LP_EMULT_UP(1,n,1,k,1),k=1,n)
!            write(56,'(i3,1p3e24.12)')n,(LP_EMULT_UP(1,n,1,k,2),k=1,n)
!            write(56,'(i3,1p3e24.12)')n,(LP_T_DELT_MUBAR(n,1,k,1),k=1,n)
!            write(56,'(i3,1p3e24.12)')n,(LP_T_DELT_MUBAR(n,1,k,2),k=1,n)
!          enddo

      ENDIF

!  Downwelling
!  ===========

      IF ( DO_DNWELLING ) THEN

!    Profiles:  loop over all varying layers K such that K </= N 

         DO N = 1, NLAYERS
           DO K = 1, N
             CALL TWOSTREAM_LP_EMULT_DN &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,& ! Dimensions
         NLAYERS, NBEAMS, N_USER_STREAMS,                    & ! input
         LAYER_VARY_FLAG(K), N, K, LAYER_VARY_NUMBER(K),     & ! input
         DELTAU_VERT, L_DELTAU_VERT,  USER_STREAMS,          & ! input
         DO_PLANE_PARALLEL, LAYER_PIS_CUTOFF, ITRANS_USERM,  & ! input
         INITIAL_TRANS, SIGMA_M, EMULT_HOPRULE, EMULT_DN,    & ! input
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                & ! input
         LP_T_DELT_MUBAR,  L_T_DELT_USERM,                   & ! input
         LP_EMULT_DN )                                         ! in/out
           ENDDO
         ENDDO

!  debug
!          DO N = 1, NLAYERS
!            write(56,'(i3,1p3e24.12)')n,(LP_EMULT_DN(1,n,1,k,1),k=1,n)
!            write(56,'(i3,1p3e24.12)')n,(LP_EMULT_DN(1,n,1,k,2),k=1,n)
!          enddo

      ENDIF

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LP_EMULTMASTER

!

SUBROUTINE TWOSTREAM_LP_EMULT_UP &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,& ! Dimensions
         NBEAMS, N_USER_STREAMS,                             & ! input
         DOVARY, N, K, K_PARAMETERS,                         & ! input
         DO_PLANE_PARALLEL, LAYER_PIS_CUTOFF, ITRANS_USERM,  & ! input
         T_DELT_MUBAR, T_DELT_USERM, SIGMA_P, EMULT_UP,      & ! input
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                & ! input
         LP_T_DELT_MUBAR,  L_T_DELT_USERM,                   & ! input
         LP_EMULT_UP )                                         ! in/out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  Inputs
!  ======

!  Dimensions

      INTEGER, INTENT(IN)        :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Numbers

      INTEGER, INTENT(IN)        :: NBEAMS, N_USER_STREAMS

!  Linearization control

      LOGICAL, INTENT(IN)        :: DOVARY
      INTEGER, INTENT(IN)        :: N, K, K_PARAMETERS

!  BEAM control

      LOGICAL, INTENT(IN)        :: DO_PLANE_PARALLEL

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)        :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  initial transittance factors for solar beams.

      REAL(kind=dp), INTENT(IN)  :: ITRANS_USERM   ( MAXLAYERS, MAX_USER_STREAMS, MAXBEAMS )

!  Transmittance factors for user-defined stream angles
!    Computed in the initial setup stage for Fourier m = 0

      REAL(kind=dp), INTENT(IN)  :: T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS )

!  Transmittance factors for average secant stream

      REAL(kind=dp), INTENT(IN)  :: T_DELT_MUBAR ( MAXLAYERS, MAXBEAMS )

!  coefficient functions for user-defined angles

      REAL(kind=dp), INTENT(IN)  :: SIGMA_P(MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)
      
!  forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(IN)  :: EMULT_UP (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)

!  Linearizations of Transmittance factors 

      REAL(kind=dp), INTENT(IN)  :: LP_INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_T_DELT_MUBAR   ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM    ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS )

!  Output
!  ======

!  Linearized forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(INOUT) :: &
        LP_EMULT_UP (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Local variables
!  ===============

      REAL(kind=dp) :: SU, V1, V2, UDEL, WDEL
      INTEGER       :: UM, Q, IB

!  Start Beam loop

      DO IB = 1, NBEAMS

!  Beyond the cutoff layer, zero the multiplier values, and move on.

       IF ( .NOT. DOVARY .OR. (N.GT.LAYER_PIS_CUTOFF(IB)) ) THEN
         DO UM = 1, N_USER_STREAMS
           DO Q = 1, K_PARAMETERS
             LP_EMULT_UP(UM,N,IB,K,Q) = 0.0d0
           ENDDO
         ENDDO
         GO TO 5678
       ENDIF

!  Profile linearizations: Two cases --------
!  (a) If N = K, multiplier for due to variations in the layer N
!  (b) If N > K, multiplier due to variations in a higher layer K
!  Column linearizations: One case ----------
!  (a) If K = 0, Multiplier for bulk (column) variations

!  transmittance factor

       WDEL = T_DELT_MUBAR(N,IB)

!  For the pseudo-spherical case
!  -----------------------------

       IF ( .NOT. DO_PLANE_PARALLEL ) THEN

!  Case(a)

        IF ( K.EQ.N ) THEN
          DO UM = 1, N_USER_STREAMS
            UDEL = T_DELT_USERM(N,UM)
            SU   = - ITRANS_USERM(N,UM,IB) / SIGMA_P(N,UM,IB)
            DO Q = 1, K_PARAMETERS
              V1 = - LP_AVERAGE_SECANT(N,IB,K,Q) / SIGMA_P(N,UM,IB)
              IF ( K.EQ.0 ) V1 = V1 + LP_INITIAL_TRANS (N,IB,K,Q)
              V2 = WDEL * L_T_DELT_USERM(N,UM,Q) + &
                   UDEL * LP_T_DELT_MUBAR(N,IB,K,Q)
              LP_EMULT_UP(UM,N,IB,K,Q) = EMULT_UP(UM,N,IB) * V1 + SU * V2
            ENDDO
          ENDDO
        ENDIF

!  Case (b)

        IF ( N.GT.K .AND. K.NE.0 ) THEN
          DO UM = 1, N_USER_STREAMS
            UDEL = T_DELT_USERM(N,UM)
            SU = - ITRANS_USERM(N,UM,IB) / SIGMA_P(N,UM,IB)
            DO Q = 1, K_PARAMETERS
              V1 = LP_INITIAL_TRANS (N,IB,K,Q) - &
                 ( LP_AVERAGE_SECANT(N,IB,K,Q) / SIGMA_P(N,UM,IB) )
              V2 =  UDEL * LP_T_DELT_MUBAR(N,IB,K,Q)
              LP_EMULT_UP(UM,N,IB,K,Q) = EMULT_UP(UM,N,IB) * V1 + SU * V2
            ENDDO
          ENDDO
        ENDIF

!  For the plane-parallel case
!  ---------------------------

      ELSE

!  Case (a)

        IF ( K.EQ.N ) THEN
          DO UM = 1, N_USER_STREAMS
            UDEL = T_DELT_USERM(N,UM)
            SU = - ITRANS_USERM(N,UM,IB) / SIGMA_P(N,UM,IB)
            DO Q = 1, K_PARAMETERS
              V1 = 0.0d0
              IF ( K.EQ.0 ) V1 = LP_INITIAL_TRANS (N,IB,K,Q)
              V2 = WDEL * L_T_DELT_USERM(N,UM,Q) + &
                   UDEL * LP_T_DELT_MUBAR(N,IB,K,Q)
              LP_EMULT_UP(UM,N,IB,K,Q) = EMULT_UP(UM,N,IB)*V1 + SU * V2
            ENDDO
          ENDDO
        ENDIF

!  Case (b)

        IF ( N.GT.K .AND. K.NE.0 ) THEN
          DO UM = 1, N_USER_STREAMS
            DO Q = 1, K_PARAMETERS
              V1 = LP_INITIAL_TRANS(N,IB,K,Q)
              LP_EMULT_UP(UM,N,IB,K,Q) = EMULT_UP(UM,N,IB) * V1
            ENDDO
          ENDDO
        ENDIF

!  End clause pseudo-spherical versus plane-parallel

       ENDIF

!  continuation point for next beam

 5678  CONTINUE

      ENDDO

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LP_EMULT_UP

!

SUBROUTINE TWOSTREAM_LP_EMULT_DN &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,& ! Dimensions
         NLAYERS, NBEAMS, N_USER_STREAMS,                    & ! input
         DOVARY, N, K, K_PARAMETERS,                         & ! input
         DELTAU_VERT, L_DELTAU_VERT, USER_STREAMS,           & ! input
         DO_PLANE_PARALLEL, LAYER_PIS_CUTOFF, ITRANS_USERM,  & ! input
         INITIAL_TRANS, SIGMA_M, EMULT_HOPRULE, EMULT_DN,    & ! input
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                & ! input
         LP_T_DELT_MUBAR,  L_T_DELT_USERM,                   & ! input
         LP_EMULT_DN )                                         ! in/out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  INPUTS
!  ======

!  Dimensions

      INTEGER, INTENT(IN)        :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Numbers

      INTEGER, INTENT(IN)        :: NLAYERS, NBEAMS, N_USER_STREAMS

!  Linearization control

      LOGICAL, INTENT(IN)        :: DOVARY
      INTEGER, INTENT(IN)        :: N, K, K_PARAMETERS

!  Layer optical thickness and linearization

      REAL(kind=dp), INTENT(IN)  :: DELTAU_VERT   ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_DELTAU_VERT ( MAXLAYERS, MAX_ATMOSWFS )

!  User streams

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )

!  BEAM control

      LOGICAL, INTENT(IN)        :: DO_PLANE_PARALLEL

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)        :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  initial transittance factors for solar beams.

      REAL(kind=dp), INTENT(IN)  :: ITRANS_USERM   ( MAXLAYERS, MAX_USER_STREAMS, MAXBEAMS )
      REAL(kind=dp), INTENT(IN)  :: INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS )

!  coefficient functions for user-defined angles

      REAL(kind=dp), INTENT(IN)  :: SIGMA_M(MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)

!  L'Hopital's rule logical variables

      LOGICAL, INTENT(IN)        :: EMULT_HOPRULE (MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)

!  forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(IN)  :: EMULT_DN (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)

!  Linearizations of Transmittance factors

      REAL(kind=dp), INTENT(IN)  :: LP_INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_T_DELT_MUBAR   ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS )

!  Output
!  ======

!  Linearized forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(INOUT) :: &
        LP_EMULT_DN (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Local variables
!  ===============

      REAL(kind=dp) :: SD, V1, V2, V3
      INTEGER       :: UM, Q, IB

!mick fix 2/10/12 - added to fully normalize linearized tau
      INTEGER       :: NN
      REAL(kind=dp) :: L_DELTAU_VERT_LOC ( MAXLAYERS, MAX_ATMOSWFS )

!  Start subroutine

!mick fix 2/10/12 - fully normalize linearized tau for computations
!                   in this subroutine

      DO Q = 1, MAX_ATMOSWFS
        DO NN = 1, NLAYERS
          L_DELTAU_VERT_LOC(NN,Q) = L_DELTAU_VERT(NN,Q)/DELTAU_VERT(NN)
        END DO
      END DO

!  Start Beam loop

      DO IB = 1, NBEAMS

!  Beyond the cutoff layer, zero the multiplier values, and move on.

       IF ( .not. DOVARY .or. N .GT. LAYER_PIS_CUTOFF(IB) ) THEN
         DO UM = 1, N_USER_STREAMS
           DO Q = 1, K_PARAMETERS
             LP_EMULT_DN(UM,N,IB,K,Q) = 0.0d0
           ENDDO
         ENDDO
         GO TO 5678
       ENDIF

!  Profile linearizations: Two cases --------
!  (a) If N = K, multiplier for due to variations in the layer N
!  (b) If N > K, multiplier due to variations in a higher layer K
!  Column linearizations: One case ----------
!  (a) If K = 0, Multiplier for bulk (column) variations
  
!  NOTE - use of L'Hopital's Rule is present in this module

!  For the pseudo-spherical case
!  -----------------------------

       IF ( .NOT. DO_PLANE_PARALLEL ) THEN

!  Case(a). Note the use of L'Hopital's Rule flag.

        IF ( K.EQ.N ) THEN
          DO UM = 1, N_USER_STREAMS
            IF ( EMULT_HOPRULE(N,UM,IB) ) THEN
              V1 = 1.0d0 - DELTAU_VERT(N) / USER_STREAMS(UM)
              V2 = - 0.5d0 * DELTAU_VERT(N)
              DO Q = 1, K_PARAMETERS
                SD = V1 * L_DELTAU_VERT_LOC(N,Q) + V2 * LP_AVERAGE_SECANT(N,IB,K,Q)
                V3 = 0.0d0
                IF ( K.EQ.0) V3 = V3 + LP_INITIAL_TRANS (N,IB,K,Q)
                LP_EMULT_DN(UM,N,IB,K,Q) = EMULT_DN(UM,N,IB) * (SD+V3)
              ENDDO
            ELSE
              SD = ITRANS_USERM(N,UM,IB) / SIGMA_M(N,UM,IB)
              DO Q = 1, K_PARAMETERS
                V1 = - LP_AVERAGE_SECANT(N,IB,K,Q) / SIGMA_M(N,UM,IB)
                IF ( K.EQ.0 ) V1 = V1 + LP_INITIAL_TRANS (N,IB,K,Q)
                V2 = L_T_DELT_USERM(N,UM,Q) - LP_T_DELT_MUBAR(N,IB,K,Q)
                LP_EMULT_DN(UM,N,IB,K,Q) = EMULT_DN(UM,N,IB)*V1 + SD*V2
              ENDDO
            ENDIF
          ENDDO
        ENDIF

!  Case (b)

        IF ( N.GT.K .AND. K.NE.0 ) THEN
          DO UM = 1, N_USER_STREAMS
            IF ( EMULT_HOPRULE(N,UM,IB) ) THEN
              V2 = - 0.5d0 * DELTAU_VERT(N)
              DO Q = 1, K_PARAMETERS
                SD = LP_INITIAL_TRANS (N,IB,K,Q) + V2 * LP_AVERAGE_SECANT(N,IB,K,Q)
                LP_EMULT_DN(UM,N,IB,K,Q) = EMULT_DN(UM,N,IB) * SD
              ENDDO
            ELSE
              SD = ITRANS_USERM(N,UM,IB) / SIGMA_M(N,UM,IB)
              DO Q = 1, K_PARAMETERS
                V1 =   LP_INITIAL_TRANS(N,IB,K,Q) - &
                    ( LP_AVERAGE_SECANT(N,IB,K,Q) / SIGMA_M(N,UM,IB) )
                V2 = - LP_T_DELT_MUBAR(N,IB,K,Q)
                LP_EMULT_DN(UM,N,IB,K,Q) = EMULT_DN(UM,N,IB)*V1 + SD*V2
              ENDDO
            ENDIF
          ENDDO
        ENDIF

!  For the plane-parallel case
!  ---------------------------

       ELSE

!  Case (a)

        IF ( K.EQ.N ) THEN
          DO UM = 1, N_USER_STREAMS
            IF ( EMULT_HOPRULE(N,UM,IB) ) THEN
              V1 = 1.0d0 - DELTAU_VERT(N) / USER_STREAMS(UM)
              DO Q = 1, K_PARAMETERS
                SD = V1 * L_DELTAU_VERT_LOC(N,Q)
                V2 = 0.0d0
                IF ( K.EQ.0.AND.INITIAL_TRANS(N,IB).NE.0.0d0) &
     &             V2 = V2 + LP_INITIAL_TRANS (N,IB,K,Q)
                LP_EMULT_DN(UM,N,IB,K,Q) = EMULT_DN(UM,N,IB) * (SD+V2)
              ENDDO
            ELSE
              SD = ITRANS_USERM(N,UM,IB) / SIGMA_M(N,UM,IB)
              DO Q = 1, K_PARAMETERS
                V1 = 0.0d0
                IF ( K.EQ.0 ) V1 = LP_INITIAL_TRANS (N,IB,K,Q)
                V2 = L_T_DELT_USERM(N,UM,Q) - LP_T_DELT_MUBAR(N,IB,K,Q)
                LP_EMULT_DN(UM,N,IB,K,Q) = EMULT_DN(UM,N,IB)*V1 + SD*V2
              ENDDO
            ENDIF
          ENDDO
        ENDIF

!  Case (b)

        IF ( N.GT.K .AND. K.NE.0 ) THEN
          DO UM = 1, N_USER_STREAMS
            DO Q = 1, K_PARAMETERS
              V1 = LP_INITIAL_TRANS(N,IB,K,Q)
              LP_EMULT_DN(UM,N,IB,K,Q) = EMULT_DN(UM,N,IB) * V1
            ENDDO
          ENDDO
        ENDIF

!  End clause pseudo-spherical versus plane-parallel

       ENDIF

!  continuation point for next beam

 5678  CONTINUE

      ENDDO

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LP_EMULT_DN

!

SUBROUTINE TWOSTREAM_LP_EMULTMASTER_OBSGEO &
          ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,  & ! Dimensions
            DO_UPWELLING, DO_DNWELLING, DO_PLANE_PARALLEL,        & ! inputs
            NLAYERS, NBEAMS, LAYER_VARY_FLAG, LAYER_VARY_NUMBER,  & ! inputs
            DELTAU_VERT, L_DELTAU_VERT,                           & ! inputs
            USER_STREAMS, T_DELT_MUBAR, T_DELT_USERM,             & ! inputs
            ITRANS_USERM, LAYER_PIS_CUTOFF,                       & ! inputs
            LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                  & ! inputs
            LP_T_DELT_MUBAR,  L_T_DELT_USERM,                     & ! inputs
            SIGMA_M, SIGMA_P, EMULT_HOPRULE, EMULT_UP, EMULT_DN,  & ! inputs
            LP_EMULT_UP, LP_EMULT_DN )                              ! output

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  Prepare multipliers for the Beam source terms

!  Dimensions

      INTEGER, INTENT(IN)        :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Control

      LOGICAL, INTENT(IN)        :: DO_UPWELLING, DO_DNWELLING

!  BEAM control

      LOGICAL, INTENT(IN)        :: DO_PLANE_PARALLEL

!  Numbers

      INTEGER, INTENT(IN)        :: NLAYERS, NBEAMS

!  Linearization control

      LOGICAL, INTENT(IN)        :: LAYER_VARY_FLAG   ( MAXLAYERS )
      INTEGER, INTENT(IN)        :: LAYER_VARY_NUMBER ( MAXLAYERS )

!  Layer optical thickness and linearization

      REAL(kind=dp), INTENT(IN)  :: DELTAU_VERT   ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_DELTAU_VERT ( MAXLAYERS, MAX_ATMOSWFS )

!  User streams

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )

!  Transmittance factors for average secant stream

      REAL(kind=dp), INTENT(IN)  :: T_DELT_MUBAR ( MAXLAYERS, MAXBEAMS )

!  Transmittance factors for user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS )

!  initial transittance factors for solar beams.

      REAL(kind=dp), INTENT(IN)  :: ITRANS_USERM   ( MAXLAYERS, MAX_USER_STREAMS, MAXBEAMS )

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)        :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  Linearizations of Transmittance factors 

      REAL(kind=dp), INTENT(IN)  :: LP_INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_T_DELT_MUBAR   ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS )

!  coefficient functions for user-defined angles

      REAL(kind=dp), INTENT(IN)  :: SIGMA_P(MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)
      REAL(kind=dp), INTENT(IN)  :: SIGMA_M(MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)
      
!  L'Hopital's rule logical variables

      LOGICAL, INTENT(IN)        :: EMULT_HOPRULE (MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)

!  forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(IN)  :: EMULT_UP (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)
      REAL(kind=dp), INTENT(IN)  :: EMULT_DN (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)

!  Output
!  ======

!  Linearized forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(OUT) :: LP_EMULT_UP (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(OUT) :: LP_EMULT_DN (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  local variables
!  ---------------

      INTEGER        ::  N, K

!  Upwelling
!  =========

      IF ( DO_UPWELLING ) THEN

!    Profiles:  loop over all varying layers K such that K </= N 

         DO N = 1, NLAYERS
            DO K = 1, N
              CALL TWOSTREAM_LP_EMULT_OG_UP &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,    & ! Dimensions
         NBEAMS, LAYER_VARY_FLAG(K), N, K, LAYER_VARY_NUMBER(K), & ! input
         DO_PLANE_PARALLEL, LAYER_PIS_CUTOFF, ITRANS_USERM,      & ! input
         T_DELT_MUBAR, T_DELT_USERM, SIGMA_P, EMULT_UP,          & ! input
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                    & ! input
         LP_T_DELT_MUBAR,  L_T_DELT_USERM,                       & ! input
         LP_EMULT_UP )                                             ! in/out
            ENDDO
         ENDDO

!  debug
!          DO N = 1, NLAYERS
!            write(56,'(i3,1p3e24.12)')n,(LP_EMULT_UP(1,n,1,k,1),k=1,n)
!            write(56,'(i3,1p3e24.12)')n,(LP_EMULT_UP(1,n,1,k,2),k=1,n)
!            write(56,'(i3,1p3e24.12)')n,(LP_T_DELT_MUBAR(n,1,k,1),k=1,n)
!            write(56,'(i3,1p3e24.12)')n,(LP_T_DELT_MUBAR(n,1,k,2),k=1,n)
!          enddo

      ENDIF

!  Downwelling
!  ===========

      IF ( DO_DNWELLING ) THEN

!    Profiles:  loop over all varying layers K such that K </= N 

         DO N = 1, NLAYERS
           DO K = 1, N
             CALL TWOSTREAM_LP_EMULT_OG_DN &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,& ! Dimensions
         NLAYERS, NBEAMS, LAYER_VARY_FLAG(K),                & ! input
         N, K, LAYER_VARY_NUMBER(K),                         & ! input
         DELTAU_VERT, L_DELTAU_VERT, USER_STREAMS,           & ! input
         DO_PLANE_PARALLEL, LAYER_PIS_CUTOFF, ITRANS_USERM,  & ! input
         SIGMA_M, EMULT_HOPRULE, EMULT_DN,                   & ! input
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                & ! input
         LP_T_DELT_MUBAR,  L_T_DELT_USERM,                   & ! input
         LP_EMULT_DN )                                         ! in/out
           ENDDO
         ENDDO

!  debug
!          DO N = 1, NLAYERS
!            write(56,'(i3,1p3e24.12)')n,(LP_EMULT_DN(1,n,1,k,1),k=1,n)
!            write(56,'(i3,1p3e24.12)')n,(LP_EMULT_DN(1,n,1,k,2),k=1,n)
!          enddo

      ENDIF

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LP_EMULTMASTER_OBSGEO

!

SUBROUTINE TWOSTREAM_LP_EMULT_OG_UP &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,& ! Dimensions
         NBEAMS, DOVARY, N, K, K_PARAMETERS,                 & ! input
         DO_PLANE_PARALLEL, LAYER_PIS_CUTOFF, ITRANS_USERM,  & ! input
         T_DELT_MUBAR, T_DELT_USERM, SIGMA_P, EMULT_UP,      & ! input
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                & ! input
         LP_T_DELT_MUBAR,  L_T_DELT_USERM,                   & ! input
         LP_EMULT_UP )                                         ! in/out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  Inputs
!  ======

!  Dimensions

      INTEGER, INTENT(IN)        :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Numbers

      INTEGER, INTENT(IN)        :: NBEAMS

!  Linearization control

      LOGICAL, INTENT(IN)        :: DOVARY
      INTEGER, INTENT(IN)        :: N, K, K_PARAMETERS

!  BEAM control

      LOGICAL, INTENT(IN)        :: DO_PLANE_PARALLEL

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)        :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  initial transittance factors for solar beams.

      REAL(kind=dp), INTENT(IN)  :: ITRANS_USERM   ( MAXLAYERS, MAX_USER_STREAMS, MAXBEAMS )

!  Transmittance factors for user-defined stream angles
!    Computed in the initial setup stage for Fourier m = 0

      REAL(kind=dp), INTENT(IN)  :: T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS )

!  Transmittance factors for average secant stream

      REAL(kind=dp), INTENT(IN)  :: T_DELT_MUBAR ( MAXLAYERS, MAXBEAMS )

!  coefficient functions for user-defined angles

      REAL(kind=dp), INTENT(IN)  :: SIGMA_P(MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)
      
!  forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(IN)  :: EMULT_UP (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)

!  Linearizations of Transmittance factors 

      REAL(kind=dp), INTENT(IN)  :: LP_INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_T_DELT_MUBAR   ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM    ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS )

!  Output
!  ======

!  Linearized forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(INOUT) :: &
        LP_EMULT_UP (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Local variables
!  ===============

      REAL(kind=dp) :: SU, V1, V2, UDEL, WDEL
      INTEGER       :: Q, IB, LUM

!  Start Beam loop

      LUM = 1

      DO IB = 1, NBEAMS

!  Beyond the cutoff layer, zero the multiplier values, and move on.

       IF ( .NOT. DOVARY .OR. (N.GT.LAYER_PIS_CUTOFF(IB)) ) THEN
          DO Q = 1, K_PARAMETERS
             LP_EMULT_UP(LUM,N,IB,K,Q) = 0.0d0
          ENDDO
          GO TO 5678
       ENDIF

!  Profile linearizations: Two cases --------
!  (a) If N = K, multiplier for due to variations in the layer N
!  (b) If N > K, multiplier due to variations in a higher layer K
!  Column linearizations: One case ----------
!  (a) If K = 0, Multiplier for bulk (column) variations

!  transmittance factor

       WDEL = T_DELT_MUBAR(N,IB)

!  For the pseudo-spherical case
!  -----------------------------

       IF ( .NOT. DO_PLANE_PARALLEL ) THEN

!  Case(a)

        IF ( K.EQ.N ) THEN
           UDEL = T_DELT_USERM(N,IB)
           SU   = - ITRANS_USERM(N,LUM,IB) / SIGMA_P(N,LUM,IB)
           DO Q = 1, K_PARAMETERS
              V1 = - LP_AVERAGE_SECANT(N,IB,K,Q) / SIGMA_P(N,LUM,IB)
              V2 = WDEL * L_T_DELT_USERM(N,IB,Q) + &
                   UDEL * LP_T_DELT_MUBAR(N,IB,K,Q)
              LP_EMULT_UP(LUM,N,IB,K,Q) = EMULT_UP(LUM,N,IB) * V1 + SU * V2
           ENDDO
        ENDIF

!  Case (b)

        IF ( N.GT.K ) THEN
           UDEL = T_DELT_USERM(N,IB)
           SU = - ITRANS_USERM(N,LUM,IB) / SIGMA_P(N,LUM,IB)
           DO Q = 1, K_PARAMETERS
              V1 = LP_INITIAL_TRANS (N,IB,K,Q) - &
                 ( LP_AVERAGE_SECANT(N,IB,K,Q) / SIGMA_P(N,LUM,IB) )
              V2 =  UDEL * LP_T_DELT_MUBAR(N,IB,K,Q)
              LP_EMULT_UP(LUM,N,IB,K,Q) = EMULT_UP(LUM,N,IB) * V1 + SU * V2
           ENDDO
        ENDIF

!  For the plane-parallel case
!  ---------------------------

      ELSE

!  Case (a)

        IF ( K.EQ.N ) THEN
           UDEL = T_DELT_USERM(N,IB)
           SU = - ITRANS_USERM(N,LUM,IB) / SIGMA_P(N,LUM,IB)
           DO Q = 1, K_PARAMETERS
              V2 = WDEL * L_T_DELT_USERM(N,IB,Q) + &
                   UDEL * LP_T_DELT_MUBAR(N,IB,K,Q)
              LP_EMULT_UP(LUM,N,IB,K,Q) = SU * V2
           ENDDO
        ENDIF

!  Case (b)

        IF ( N.GT.K  ) THEN
           DO Q = 1, K_PARAMETERS
              V1 = LP_INITIAL_TRANS(N,IB,K,Q)
              LP_EMULT_UP(LUM,N,IB,K,Q) = EMULT_UP(LUM,N,IB) * V1
           ENDDO
        ENDIF

!  End clause pseudo-spherical versus plane-parallel

       ENDIF

!  continuation point for next beam

 5678  CONTINUE

      ENDDO

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LP_EMULT_OG_UP

!

SUBROUTINE TWOSTREAM_LP_EMULT_OG_DN &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,& ! Dimensions
         NLAYERS, NBEAMS, DOVARY, N, K, K_PARAMETERS,        & ! input
         DELTAU_VERT, L_DELTAU_VERT, USER_STREAMS,           & ! input
         DO_PLANE_PARALLEL, LAYER_PIS_CUTOFF, ITRANS_USERM,  & ! input
         SIGMA_M, EMULT_HOPRULE, EMULT_DN,                   & ! input
         LP_INITIAL_TRANS, LP_AVERAGE_SECANT,                & ! input
         LP_T_DELT_MUBAR,  L_T_DELT_USERM,                   & ! input
         LP_EMULT_DN )                                         ! in/out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  INPUTS
!  ======

!  Dimensions

      INTEGER, INTENT(IN)        :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Numbers

      INTEGER, INTENT(IN)        :: NLAYERS, NBEAMS

!  Linearization control

      LOGICAL, INTENT(IN)        :: DOVARY
      INTEGER, INTENT(IN)        :: N, K, K_PARAMETERS

!  Layer optical thickness and linearization

      REAL(kind=dp), INTENT(IN)  :: DELTAU_VERT   ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_DELTAU_VERT ( MAXLAYERS, MAX_ATMOSWFS )

!  User streams

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )

!  BEAM control

      LOGICAL, INTENT(IN)        :: DO_PLANE_PARALLEL

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)        :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  initial transittance factors for solar beams.

      REAL(kind=dp), INTENT(IN)  :: ITRANS_USERM   ( MAXLAYERS, MAX_USER_STREAMS, MAXBEAMS )

!  coefficient functions for user-defined angles

      REAL(kind=dp), INTENT(IN)  :: SIGMA_M(MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)

!  L'Hopital's rule logical variables

      LOGICAL, INTENT(IN)        :: EMULT_HOPRULE (MAXLAYERS,MAX_USER_STREAMS,MAXBEAMS)

!  forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(IN)  :: EMULT_DN (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)

!  Linearizations of Transmittance factors

      REAL(kind=dp), INTENT(IN)  :: LP_INITIAL_TRANS  ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: LP_T_DELT_MUBAR   ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS )

!  Output
!  ======

!  Linearized forcing term multipliers (saved for whole atmosphere)

      REAL(kind=dp), INTENT(INOUT) :: &
        LP_EMULT_DN (MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Local variables
!  ===============

      REAL(kind=dp) :: SD, V1, V2
      INTEGER       :: Q, IB, LUM

!mick fix 2/10/12 - added to fully normalize linearized tau
      INTEGER       :: NN
      REAL(kind=dp) :: L_DELTAU_VERT_LOC ( MAXLAYERS, MAX_ATMOSWFS )

!  Start subroutine

!mick fix 2/10/12 - fully normalize linearized tau for computations
!                   in this subroutine

      DO Q = 1, MAX_ATMOSWFS
        DO NN = 1, NLAYERS
          L_DELTAU_VERT_LOC(NN,Q) = L_DELTAU_VERT(NN,Q)/DELTAU_VERT(NN)
        END DO
      END DO

!  Start Beam loop

      DO IB = 1, NBEAMS

      LUM = 1

!  Beyond the cutoff layer, zero the multiplier values, and move on.

       IF ( .not. DOVARY .or. N .GT. LAYER_PIS_CUTOFF(IB) ) THEN
          DO Q = 1, K_PARAMETERS
             LP_EMULT_DN(LUM,N,IB,K,Q) = 0.0d0
          ENDDO
          GO TO 5678
       ENDIF

!  Profile linearizations: Two cases --------
!  (a) If N = K, multiplier for due to variations in the layer N
!  (b) If N > K, multiplier due to variations in a higher layer K
!  Column linearizations: One case ----------
!  (a) If K = 0, Multiplier for bulk (column) variations
  
!  NOTE - use of L'Hopital's Rule is present in this module

!  For the pseudo-spherical case
!  -----------------------------

       IF ( .NOT. DO_PLANE_PARALLEL ) THEN

!  Case(a). Note the use of L'Hopital's Rule flag.

        IF ( K.EQ.N ) THEN
           IF ( EMULT_HOPRULE(N,LUM,IB) ) THEN
              V1 = 1.0d0 - DELTAU_VERT(N) / USER_STREAMS(IB)
              V2 = - 0.5d0 * DELTAU_VERT(N)
              DO Q = 1, K_PARAMETERS
                SD = V1 * L_DELTAU_VERT_LOC(N,Q) + V2 * LP_AVERAGE_SECANT(N,IB,K,Q)
                LP_EMULT_DN(LUM,N,IB,K,Q) = EMULT_DN(LUM,N,IB) * SD 
              ENDDO
           ELSE
              SD = ITRANS_USERM(N,LUM,IB) / SIGMA_M(N,LUM,IB)
              DO Q = 1, K_PARAMETERS
                V1 = - LP_AVERAGE_SECANT(N,IB,K,Q) / SIGMA_M(N,LUM,IB)
                V2 = L_T_DELT_USERM(N,IB,Q) - LP_T_DELT_MUBAR(N,IB,K,Q)
                LP_EMULT_DN(LUM,N,IB,K,Q) = EMULT_DN(LUM,N,IB)*V1 + SD*V2
              ENDDO
           ENDIF
        ENDIF

!  Case (b)

        IF ( N.GT.K ) THEN
           IF ( EMULT_HOPRULE(N,LUM,IB) ) THEN
              V2 = - 0.5d0 * DELTAU_VERT(N)
              DO Q = 1, K_PARAMETERS
                SD = LP_INITIAL_TRANS (N,IB,K,Q) + V2 * LP_AVERAGE_SECANT(N,IB,K,Q)
                LP_EMULT_DN(LUM,N,IB,K,Q) = EMULT_DN(LUM,N,IB) * SD
              ENDDO
           ELSE
              SD = ITRANS_USERM(N,LUM,IB) / SIGMA_M(N,LUM,IB)
              DO Q = 1, K_PARAMETERS
                V1 =   LP_INITIAL_TRANS(N,IB,K,Q) - &
                    ( LP_AVERAGE_SECANT(N,IB,K,Q) / SIGMA_M(N,LUM,IB) )
                V2 = - LP_T_DELT_MUBAR(N,IB,K,Q)
                LP_EMULT_DN(LUM,N,IB,K,Q) = EMULT_DN(LUM,N,IB)*V1 + SD*V2
              ENDDO
           ENDIF
        ENDIF

!  For the plane-parallel case
!  ---------------------------

       ELSE

!  Case (a)

        IF ( K.EQ.N ) THEN
           IF ( EMULT_HOPRULE(N,LUM,IB) ) THEN
              V1 = 1.0d0 - DELTAU_VERT(N) / USER_STREAMS(IB)
              DO Q = 1, K_PARAMETERS
                SD = V1 * L_DELTAU_VERT_LOC(N,Q)
                LP_EMULT_DN(LUM,N,IB,K,Q) = EMULT_DN(LUM,N,IB) * SD
              ENDDO
           ELSE
              SD = ITRANS_USERM(N,LUM,IB) / SIGMA_M(N,LUM,IB)
              DO Q = 1, K_PARAMETERS
                V2 = L_T_DELT_USERM(N,IB,Q) - LP_T_DELT_MUBAR(N,IB,K,Q)
                LP_EMULT_DN(LUM,N,IB,K,Q) = SD * V2
              ENDDO
           ENDIF
        ENDIF

!  Case (b)

        IF ( N.GT.K ) THEN
           DO Q = 1, K_PARAMETERS
              V1 = LP_INITIAL_TRANS(N,IB,K,Q)
              LP_EMULT_DN(LUM,N,IB,K,Q) = EMULT_DN(LUM,N,IB) * V1
           ENDDO
        ENDIF

!  End clause pseudo-spherical versus plane-parallel

       ENDIF

!  continuation point for next beam

 5678  CONTINUE

      ENDDO

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LP_EMULT_OG_DN

end module twostream_lp_miscsetups_m
