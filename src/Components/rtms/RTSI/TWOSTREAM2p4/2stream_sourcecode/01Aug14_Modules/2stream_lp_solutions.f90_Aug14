! ###########################################################
! #                                                         #
! #             THE TWOSTREAM LIDORT MODEL                  #
! #                                                         #
! #      (LInearized Discrete Ordinate Radiative Transfer)  #
! #       --         -        -        -         -          #
! #                                                         #
! ###########################################################

! ###########################################################
! #                                                         #
! #  Authors :      Robert. J. D. Spurr (1)                 #
! #                 Vijay Natraj        (2)                 #
! #                                                         #
! #  Address (1) :     RT Solutions, Inc.                   #
! #                    9 Channing Street                    #
! #                    Cambridge, MA 02138, USA             #
! #  Tel:             (617) 492 1183                        #
! #  Email :           rtsolutions@verizon.net              #
! #                                                         #
! #  Address (2) :     CalTech                              #
! #                    Department of Planetary Sciences     #
! #                    1200 East California Boulevard       #
! #                    Pasadena, CA 91125                   #
! #  Tel:             (626) 395 6962                        #
! #  Email :           vijay@gps.caltech.edu                #
! #                                                         #
! #  Version 1.0-1.3 :                                      #
! #     Mark 1: October  2010                               #
! #     Mark 2: May      2011, with BRDFs                   #
! #     Mark 3: October  2011, with Thermal sources         #
! #                                                         #
! #  Version 2.0-2.1 :                                      #
! #     Mark 4: November 2012, LCS/LPS Split, Fixed Arrays  #
! #     Mark 5: December 2012, Observation Geometry option  #
! #                                                         #
! #  Version 2.2-2.3 :                                      #
! #     Mark 6: July     2013, Level outputs + control      #
! #     Mark 7: December 2013, Flux outputs  + control      #
! #     Mark 8: January  2014, Surface Leaving + control    #
! #     Mark 9: June     2014, Inverse Pentadiagonal        #
! #                                                         #
! ###########################################################

! #############################################################
! #                                                           #
! #   This Version of LIDORT-2STREAM comes with a GNU-style   #
! #   license. Please read the license carefully.             #
! #                                                           #
! #############################################################

! ###############################################################
! #                                                             #
! # Subroutines in this Module                                  #
! #                                                             #
! #     Particular integrals                                    #
! #                                                             #
! #              TWOSTREAM_LP_BEAM_SOLUTION                     #
! #              TWOSTREAM_LP_BEAM_USERSOLUTION                 #
! #                                                             #
! ###############################################################

module twostream_lp_solutions_m

PUBLIC

contains

SUBROUTINE TWOSTREAM_LP_BEAM_SOLUTION &
         ( MAXLAYERS, MAXBEAMS, MAX_ATMOSWFS,                 & ! DImensions
           DO_PLANE_PARALLEL, N, FOURIER, IBEAM, FLUX_FACTOR, & ! Input
           LAYER_PIS_CUTOFF, STREAM_VALUE, PX0X,              & ! Input
           LAYER_VARY_FLAG, LAYER_VARY_NUMBER,                & ! Input
           OMEGA, ASYMM, L_OMEGA, L_ASYMM,                    & ! Input
           SAB, DAB, EIGENVALUE, AVERAGE_SECANT,              & ! Input
           QSUMVEC, QDIFVEC, QVEC,                            & ! Input
           LP_AVERAGE_SECANT, L_SAB, L_DAB, L_EIGENVALUE,     & ! Input
           LP_WVEC )                                            ! In/Out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  subroutine arguments
!  --------------------

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAXBEAMS, MAX_ATMOSWFS

!  Given layer index and Fourier number, Beam number (inputs)

      INTEGER, INTENT(IN)  :: N
      INTEGER, INTENT(IN)  :: FOURIER
      INTEGER, INTENT(IN)  :: IBEAM

!  Plane Parallel flag

      LOGICAL, INTENT(IN)  :: DO_PLANE_PARALLEL

!  Flux factor

      REAL(kind=dp), INTENT(IN)  :: FLUX_FACTOR

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)  :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  Stream value

      REAL(kind=dp), INTENT(IN)  :: STREAM_VALUE

!  Beam SZA cosine functions

      REAL(kind=dp), INTENT(IN)  :: PX0X(MAXBEAMS)

!  Linearization control

      LOGICAL, INTENT(IN)  :: LAYER_VARY_FLAG(MAXLAYERS)
      INTEGER, INTENT(IN)  :: LAYER_VARY_NUMBER(MAXLAYERS)

!  Average-secants

      REAL(kind=dp), INTENT(IN)  :: AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS )

!  OMEGA and ASYMM

      REAL(kind=dp), INTENT(IN)  :: OMEGA ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: ASYMM ( MAXLAYERS )

!  local matrices from eigenvalue computation

      REAL(kind=dp), INTENT(IN)  :: SAB(MAXLAYERS), DAB(MAXLAYERS)

!  Eigenvalues

      REAL(kind=dp), INTENT(IN)  :: EIGENVALUE(MAXLAYERS)

!  Auxiliary vectors

      REAL(kind=dp), INTENT(IN)  :: QSUMVEC(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: QDIFVEC(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: QVEC   (MAXLAYERS)

!  Linearizations

      REAL(kind=dp), INTENT(IN)  :: L_OMEGA       ( MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_ASYMM       ( MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_SAB         ( MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_DAB         ( MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_EIGENVALUE  ( MAXLAYERS, MAX_ATMOSWFS )

      REAL(kind=dp), INTENT(IN)  :: LP_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS )

!  Output variables
!  ----------------

!  Linearized Beam solution

      REAL(kind=dp), INTENT(INOUT) :: LP_WVEC(2,MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

!  help variables
!  --------------

      LOGICAL       :: DO_FIRST, DO_PSVAR
      INTEGER       :: NV, NP, K, Q
      REAL(kind=dp) :: TP, TM, SECBAR, XINV, F1
      REAL(kind=dp) :: QMAT, QFIN, QAUX, PI4
      REAL(kind=dp) :: L_SECBAR, L_INV_X0SQUARE
      REAL(kind=dp) :: L_OMEGA_ASYMM, L_QMAT, L_EIGEN_SQUARE
      REAL(kind=dp) :: L_QSUMVEC, L_QDIFVEC, L_HELP, L_QAUX, L_QVEC

!  Flux factor and other constants

      PI4 = 4.0d0 * dacos(-1.0d0)
      F1  = FLUX_FACTOR / PI4
      NV  = 0
      XINV = 1.0d0 / STREAM_VALUE

!  Only a solution if the layer is not below Cutoff.

      DO_FIRST = ( N .LE. LAYER_PIS_CUTOFF(IBEAM) )

!  Pseudo-spherical variation condition

      DO_PSVAR = ( .NOT. DO_PLANE_PARALLEL .AND. N.GT.1 )

!   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ THIS CODE MOVED to HERE
!  Set layer to vary

      NV = N
      NP = LAYER_VARY_NUMBER(N)

!  Skip this section if there is nothing varying
!    [ Zero the boundary layer values and start Part 2 ]

      IF ( .NOT. LAYER_VARY_FLAG(N) .OR. .NOT. DO_FIRST) THEN
        DO Q = 1, NP
          LP_WVEC(1,N,NV,Q) = 0.0d0
          LP_WVEC(2,N,NV,Q) = 0.0d0
        ENDDO
        GO TO 2222
      ENDIF
!   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ END THIS CODE MOVED to HERE

!  solar zenith cosine for this layer

      SECBAR   = AVERAGE_SECANT(N,IBEAM)

!  set up driving vector (using saved results)
!  This must be done regardless of whether layer N is varying or not.

      QMAT = EIGENVALUE(N) * EIGENVALUE(N) - SECBAR * SECBAR
      QFIN = - SAB(N) * QVEC(N)
      QAUX = ( QFIN - QSUMVEC(N) ) / SECBAR

!  Linearization for layer N is in two parts:
!    1A. Linearization due to variations in Layer N itself (Profiles)
!    1B. Linearization due to columns    
!    2. Linearization due to variations in layers K < N (Profiles)

!  Part 1.
!  =======

! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! @@@@@@@@@@@  ABOVE CODE BLOCK MOVED FROM HERE @@@@@@@@@@@@@@@@
! @@@@ Bug implemented 04 June 2012, courtesy V. Natraj @@@@@@@
! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

!  For each varying parameter

      DO Q = 1, NP

!  linearizations

        L_SECBAR       = Lp_AVERAGE_SECANT(N,IBEAM,NV,Q)
        L_OMEGA_ASYMM  = 3.0d0 *  &
            ( L_OMEGA(N,Q)*ASYMM(N) + OMEGA(N)*L_ASYMM(N,Q) )
        L_EIGEN_SQUARE = 2.0d0 * L_EIGENVALUE(N,Q) * EIGENVALUE(N)
        L_INV_X0SQUARE = 2.0d0 * L_SECBAR * SECBAR

!  Set up sum and differences for Beam source terms

        if ( fourier.eq.0) then
          TP = L_OMEGA(N,Q) + PX0X(IBEAM) * L_OMEGA_ASYMM
          TM = L_OMEGA(N,Q) - PX0X(IBEAM) * L_OMEGA_ASYMM
        Else if ( fourier .eq. 1 ) then
          TP = PX0X(IBEAM) * L_OMEGA_ASYMM
          TM = PX0X(IBEAM) * L_OMEGA_ASYMM
        ENDIF
        L_QSUMVEC = F1 * ( TP + TM ) * XINV
        L_QDIFVEC = F1 * ( TP - TM ) * XINV

!  Linearize the reduced problem

        L_HELP = - L_DAB(N,Q) * QSUMVEC(N) - DAB(N) * L_QSUMVEC
        L_QMAT = L_EIGEN_SQUARE - L_INV_X0SQUARE
        L_QVEC = L_HELP + L_QDIFVEC * SECBAR 
        IF ( DO_PSVAR ) THEN
          L_QVEC = L_QVEC + QDIFVEC(N) * L_SECBAR
        ENDIF
        L_QVEC = ( L_QVEC - QVEC(N) * L_QMAT ) / QMAT

!  Restore up and down solutions

        L_HELP = - L_SAB(N,Q) * QVEC(N) - SAB(N) * L_QVEC
        L_QAUX = ( L_HELP - L_QSUMVEC ) / SECBAR
        IF ( DO_PSVAR ) THEN
          L_QAUX = L_QAUX - QAUX * L_SECBAR / SECBAR
        ENDIF
        LP_WVEC(1,N,NV,Q) = 0.5d0 * ( L_QVEC + L_QAUX )
        LP_WVEC(2,N,NV,Q) = 0.5d0 * ( L_QVEC - L_QAUX )

!  End parameter loop

      ENDDO

!  debug
!        if (fourier.eq.0)write(*,'(2i4,1p3e24.12)')n,nv,
!     &         LP_WVEC(1,N,NV,1),LP_WVEC(1,N,NV,2)

!  Part 2.
!  =======

!  Continuation point

 2222 CONTINUE

!  Only for the pseudo-spherical case, profile weighting functions

!  Also not required for the column weighting functions

      IF ( DO_PLANE_PARALLEL )       RETURN

!  No particular solution beyond the cutoff layer.
!  No solution if layer is inactive
!    [ Zero the boundary layer values and exit ]

      IF ( .NOT. DO_FIRST) THEN
        DO K = 1, N - 1
          DO Q = 1, LAYER_VARY_NUMBER(K)
            LP_WVEC(1,N,K,Q) = 0.0d0
            LP_WVEC(2,N,K,Q) = 0.0d0
          ENDDO
        ENDDO
        RETURN
      ENDIF

!  Loop over layers K above N

      DO K = 1, N - 1

!  If there is a varying layer

        IF ( LAYER_VARY_FLAG(K) ) THEN

!  Start loop over parameters

          DO Q = 1, LAYER_VARY_NUMBER(K)

!  linearizations

            L_SECBAR       = LP_AVERAGE_SECANT(N,IBEAM,K,Q)
            L_INV_X0SQUARE = 2.0d0 * L_SECBAR * SECBAR

!  Linearize the reduced problem

            L_QMAT = - L_INV_X0SQUARE
            L_QVEC = QDIFVEC(N) * L_SECBAR
            L_QVEC = ( L_QVEC - QVEC(N) * L_QMAT ) / QMAT

!  Restore up and down solutions

            L_QAUX =  - ( SAB(N) * L_QVEC + QAUX * L_SECBAR ) / SECBAR
            LP_WVEC(1,N,K,Q) = 0.5d0 * ( L_QVEC + L_QAUX )
            LP_WVEC(2,N,K,Q) = 0.5d0 * ( L_QVEC - L_QAUX )

!  End loops

          ENDDO
        ENDIF
      ENDDO

!  debug
!        if (fourier.eq.0)then
!       write(*,'(2i4,1p3e24.12)')n,1,(LP_WVEC(2,N,K,1),k=1,N)
!       write(*,'(2i4,1p3e24.12)')n,2,(LP_WVEC(2,N,K,2),k=1,N)
!        endif
!        if (n.eq.3)pause

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LP_BEAM_SOLUTION

!

SUBROUTINE TWOSTREAM_LP_BEAM_USERSOLUTION &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,       & ! Dimensions
         DO_UPWELLING, DO_DNWELLING,                                & ! Input
         DO_USER_OBSGEOMS, DO_PLANE_PARALLEL,                       & ! Input
         N_USER_STREAMS, N, FOURIER, IBEAM,                         & ! Input
         LAYER_VARY_FLAG, LAYER_VARY_NUMBER,                        & ! Input
         FLUX_FACTOR, LAYER_PIS_CUTOFF, USER_STREAMS, STREAM_VALUE, & ! Input
         PX11, ULP,OMEGA, ASYMM, L_OMEGA, L_ASYMM, W_HELP, LP_WVEC, & ! Input
         LP_U_WPOS2, LP_U_WNEG2 )                                     ! In/Out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  subroutine arguments
!  --------------------

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Flags

      LOGICAL, INTENT(IN)  :: DO_UPWELLING, DO_DNWELLING

!   !@@ Observational Geometry flag !@@

      LOGICAL, INTENT(IN)  :: DO_USER_OBSGEOMS !@@

!  Plane Parallel flag

      LOGICAL, INTENT(IN)  :: DO_PLANE_PARALLEL

!  Numbers

      INTEGER, INTENT(IN)  :: N_USER_STREAMS

!  Given layer index and Fourier number, Beam number (inputs)

      INTEGER, INTENT(IN)  :: N
      INTEGER, INTENT(IN)  :: FOURIER
      INTEGER, INTENT(IN)  :: IBEAM

!  Linearization control

      LOGICAL, INTENT(IN)  :: LAYER_VARY_FLAG(MAXLAYERS)
      INTEGER, INTENT(IN)  :: LAYER_VARY_NUMBER(MAXLAYERS)

!  Flux factor

      REAL(kind=dp), INTENT(IN)  :: FLUX_FACTOR

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)  :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  Stream value and polynomial

      REAL(kind=dp), INTENT(IN)  :: STREAM_VALUE, PX11

!  Beam SZA cosines
!      REAL(kind=dp), INTENT(IN)  :: X0(MAXBEAMS)
!      REAL(kind=dp), INTENT(IN)  :: POX(MAXBEAMS)

!  OMEGA and ASYMM, + linearizations

      REAL(kind=dp), INTENT(IN)  :: OMEGA ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: ASYMM ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_OMEGA ( MAXLAYERS,MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_ASYMM ( MAXLAYERS,MAX_ATMOSWFS )

!  User streams

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )
      REAL(kind=dp), INTENT(IN)  :: ULP          ( MAX_USER_STREAMS )

!  Saved help variables

      REAL(kind=dp), INTENT(IN)  :: W_HELP(0:1)

!  Linearized Beam solutions

      REAL(kind=dp), INTENT(IN)  :: LP_WVEC(2,MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

!  Subroutine output arguments
!  ---------------------------

!  Diffuse-term Particular beam solutions at user-defined angles

      REAL(kind=dp), INTENT(INOUT) :: LP_U_WPOS2(MAX_USER_STREAMS,MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(INOUT) :: LP_U_WNEG2(MAX_USER_STREAMS,MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

!  Single-scatter Particular beam solutions at user-defined angles
!    NOT REQUIRED, MS_MODE only2 = Diffuse term contribution
!      REAL(kind=dp), INTENT(INOUT) :: L_U_WPOS1(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(INOUT) :: L_U_WNEG1(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Local variables
!  ---------------

      LOGICAL       :: DO_FIRST
      INTEGER       :: UM, NV, K, Q
      REAL(kind=dp) :: POS2, F1, OMEGA_MOM, PI4, HMUS, HPX11
      REAL(kind=dp) :: L_OMEGA_MOM, l_h2(0:1), l_w(0:1)

      NV = N

!  No particular solution beyond the cutoff layer
!  ... Zero the user solutions and exit

!  Only a solution if the layer is not below Cutoff.

      DO_FIRST = ( N .LE. LAYER_PIS_CUTOFF(IBEAM) )

!  If no solution or no variation, zero output and go to Part 2

      IF ( .NOT. LAYER_VARY_FLAG(N) .OR. .NOT. DO_FIRST ) THEN
        IF ( DO_USER_OBSGEOMS ) THEN
          IF ( DO_UPWELLING ) THEN
            DO Q = 1, LAYER_VARY_NUMBER(N)
              LP_U_WPOS2(IBEAM,N,NV,Q) = 0.0d0
            ENDDO
          ENDIF
          IF ( DO_DNWELLING ) THEN
            DO Q = 1, LAYER_VARY_NUMBER(N)
              LP_U_WNEG2(IBEAM,N,NV,Q) = 0.0d0
            ENDDO
          ENDIF
        ELSE
          DO UM = 1, N_USER_STREAMS
            IF ( DO_UPWELLING ) THEN
              DO Q = 1, LAYER_VARY_NUMBER(N)
                LP_U_WPOS2(UM,N,NV,Q) = 0.0d0
              ENDDO
            ENDIF
            IF ( DO_DNWELLING ) THEN
              DO Q = 1, LAYER_VARY_NUMBER(N)
                LP_U_WNEG2(UM,N,NV,Q) = 0.0d0
              ENDDO
            ENDIF
          ENDDO
        ENDIF
        GO TO 2222
      ENDIF

!  set up numbers

      PI4 = 4.0d0 * dacos(-1.0d0)
      F1 = FLUX_FACTOR / PI4
      OMEGA_MOM  = 3.0d0 * OMEGA(N) * ASYMM(N)
      HMUS       = STREAM_VALUE * 0.5d0
      IF ( FOURIER.EQ.1 ) HPX11 = PX11 * 0.5d0

!  Start parameter loop

      DO Q = 1, LAYER_VARY_NUMBER(N)

!  basi! optical property variation

        L_OMEGA_MOM = L_OMEGA(N,Q)*ASYMM(N)+OMEGA(N)*L_ASYMM(N,Q)
        L_OMEGA_MOM = 3.0d0 * L_OMEGA_MOM

!  Eigenvector interpolation to user-defined angles
!  ------------------------------------------------

!  For each moment, do inner sum over computational angles
!  for the positive and negative eigenvectors

        if ( fourier.eq.0) then
          l_w(0)   = ( LP_WVEC(2,N,NV,Q) + LP_WVEC(1,N,NV,Q) ) * 0.5d0
          l_w(1)   = ( LP_WVEC(2,N,NV,Q) - LP_WVEC(1,N,NV,Q) ) * HMUS
          l_h2(0)  = l_w(0) * omega(n)  + w_help(0) * l_omega(n,q)
          l_h2(1)  = l_w(1) * omega_mom + w_help(1) * l_omega_mom
        else
          l_w(1)   = - ( LP_WVEC(2,N,NV,Q) + LP_WVEC(1,N,NV,Q) )* HPX11
          l_h2(1)  = l_w(1) * omega_mom + w_help(1) * l_omega_mom
        endif

!  Now sum over all harmonic contributions at each user-defined stream
!  Distinguish between upwelling and downwelling

        IF ( DO_UPWELLING ) THEN
          IF ( DO_USER_OBSGEOMS ) THEN
            if (fourier.eq.0 ) then
              pos2 = l_h2(0) + l_h2(1) * user_streams(IBEAM)
            else
              pos2 = l_h2(1) * ULP(IBEAM)
            endif
            LP_U_WPOS2(IBEAM,N,NV,Q) = POS2
          ELSE
            DO UM = 1, N_USER_STREAMS
              if (fourier.eq.0 ) then
                pos2 = l_h2(0) + l_h2(1) * user_streams(UM)
              else
                pos2 = l_h2(1) * ULP(UM)
              endif
              LP_U_WPOS2(UM,N,NV,Q) = POS2
            ENDDO
          ENDIF
        ENDIF

        IF ( DO_DNWELLING ) THEN
          IF ( DO_USER_OBSGEOMS ) THEN
            if (fourier.eq.0 ) then
              pos2 = l_h2(0) - l_h2(1) * user_streams(IBEAM)
            else
              pos2 = l_h2(1) * ULP(IBEAM)
            endif
            LP_U_WNEG2(IBEAM,N,NV,Q) = POS2
          ELSE
            DO UM = 1, N_USER_STREAMS
              if (fourier.eq.0 ) then
                pos2 = l_h2(0) - l_h2(1) * user_streams(UM)
              else
                pos2 = l_h2(1) * ULP(UM)
              endif
              LP_U_WNEG2(UM,N,NV,Q) = POS2
            ENDDO
          ENDIF
        ENDIF

!  End parameter loop

      enddo

!  Part 2.
!  =======

!  Continuation point

 2222 continue

!  The following zeroing is very important

      IF ( DO_USER_OBSGEOMS ) THEN
        DO K = 1, N - 1
          DO Q = 1, LAYER_VARY_NUMBER(K)
            LP_U_WPOS2(IBEAM,N,K,Q) = 0.0d0
            LP_U_WNEG2(IBEAM,N,K,Q) = 0.0d0
          ENDDO
        ENDDO
      ELSE
        DO K = 1, N - 1
          DO Q = 1, LAYER_VARY_NUMBER(K)
            DO UM = 1, N_USER_STREAMS
              LP_U_WPOS2(UM,N,K,Q) = 0.0d0
              LP_U_WNEG2(UM,N,K,Q) = 0.0d0
            ENDDO
          ENDDO
        ENDDO
      ENDIF

!  Only these extra variations when the following conditions
!  are not satisfied (pseudo-spherical, layer > 1)
!  Profiles only

      IF ( N .EQ. 1 )                RETURN
      IF ( DO_PLANE_PARALLEL )       RETURN

!  If no solution, zero output and exit

      IF ( .NOT. DO_FIRST ) THEN
        IF ( DO_USER_OBSGEOMS ) THEN
          DO K = 1, N - 1
            DO Q = 1, LAYER_VARY_NUMBER(K)
              LP_U_WPOS2(IBEAM,N,K,Q) = 0.0d0
              LP_U_WNEG2(IBEAM,N,K,Q) = 0.0d0
            ENDDO
          ENDDO
          RETURN
        ELSE
          DO K = 1, N - 1
            DO Q = 1, LAYER_VARY_NUMBER(K)
              DO UM = 1, N_USER_STREAMS
                LP_U_WPOS2(UM,N,K,Q) = 0.0d0
                LP_U_WNEG2(UM,N,K,Q) = 0.0d0
              ENDDO
            ENDDO
          ENDDO
          RETURN
        ENDIF
      ENDIF

!  start loop over all layers above N

      DO K = 1, N - 1

!  only do if layer K has some variation

        IF ( LAYER_VARY_FLAG(K) ) THEN

!  start parameter loop

          DO Q = 1, LAYER_VARY_NUMBER(K)

!  For each moment, do inner sum over computational angles
!  for the positive and negative eigenvectors

            if ( fourier.eq.0) then
              l_w(0)   = ( LP_WVEC(2,N,K,Q) + LP_WVEC(1,N,K,Q) ) * 0.5d0
              l_w(1)   = ( LP_WVEC(2,N,K,Q) - LP_WVEC(1,N,K,Q) ) * HMUS
              l_h2(0)  = l_w(0) * omega(n)
              l_h2(1)  = l_w(1) * omega_mom
            else
              l_w(1)   = - ( LP_WVEC(2,N,K,Q) + LP_WVEC(1,N,K,Q) ) * HPX11
              l_h2(1)  = l_w(1) * omega_mom
            endif

!  Now sum over all harmoni! contributions at each user-defined stream
!  Distinguish between upwelling and downwelling

            IF ( DO_UPWELLING ) THEN
              IF ( DO_USER_OBSGEOMS ) THEN
                if (fourier.eq.0 ) then
                  pos2 = l_h2(0) + l_h2(1) * user_streams(IBEAM)
                else
                  pos2 = l_h2(1) * ULP(IBEAM)
                endif
                LP_U_WPOS2(IBEAM,N,K,Q) = POS2
              ELSE
                DO UM = 1, N_USER_STREAMS
                  if (fourier.eq.0 ) then
                    pos2 = l_h2(0) + l_h2(1) * user_streams(UM)
                  else
                    pos2 = l_h2(1) * ULP(UM)
                  endif
                  LP_U_WPOS2(UM,N,K,Q) = POS2
                ENDDO
              ENDIF
            ENDIF

            IF ( DO_DNWELLING ) THEN
              IF ( DO_USER_OBSGEOMS ) THEN
                if (fourier.eq.0 ) then
                  pos2 = l_h2(0) - l_h2(1) * user_streams(IBEAM)
                else
                  pos2 = l_h2(1) * ULP(IBEAM)
                endif
                LP_U_WNEG2(IBEAM,N,K,Q) = POS2
              ELSE
                DO UM = 1, N_USER_STREAMS
                  if (fourier.eq.0 ) then
                    pos2 = l_h2(0) - l_h2(1) * user_streams(UM)
                  else
                    pos2 = l_h2(1) * ULP(UM)
                  endif
                  LP_U_WNEG2(UM,N,K,Q) = POS2
                ENDDO
              ENDIF
            ENDIF

!  end parameter loop

          ENDDO

!  end K-layer loop

        ENDIF
      ENDDO

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LP_BEAM_USERSOLUTION

end module twostream_lp_solutions_m
