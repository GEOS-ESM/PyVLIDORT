! ###########################################################
! #                                                         #
! #             THE TWOSTREAM LIDORT MODEL                  #
! #                                                         #
! #      (LInearized Discrete Ordinate Radiative Transfer)  #
! #       --         -        -        -         -          #
! #                                                         #
! ###########################################################

! ###########################################################
! #                                                         #
! #  Authors :      Robert. J. D. Spurr (1)                 #
! #                 Vijay Natraj        (2)                 #
! #                                                         #
! #  Address (1) :     RT Solutions, Inc.                   #
! #                    9 Channing Street                    #
! #                    Cambridge, MA 02138, USA             #
! #  Tel:             (617) 492 1183                        #
! #  Email :           rtsolutions@verizon.net              #
! #                                                         #
! #  Address (2) :     CalTech                              #
! #                    Department of Planetary Sciences     #
! #                    1200 East California Boulevard       #
! #                    Pasadena, CA 91125                   #
! #  Tel:             (626) 395 6962                        #
! #  Email :           vijay@gps.caltech.edu                #
! #                                                         #
! #  Version 1.0-1.3 :                                      #
! #     Mark 1: October  2010                               #
! #     Mark 2: May      2011, with BRDFs                   #
! #     Mark 3: October  2011, with Thermal sources         #
! #                                                         #
! #  Version 2.0-2.1 :                                      #
! #     Mark 4: November 2012, LCS/LPS Split, Fixed Arrays  #
! #     Mark 5: December 2012, Observation Geometry option  #
! #                                                         #
! #  Version 2.2-2.3 :                                      #
! #     Mark 6: July     2013, Level outputs + control      #
! #     Mark 7: December 2013, Flux outputs  + control      #
! #     Mark 8: January  2014, Surface Leaving + control    #
! #     Mark 9: June     2014, Inverse Pentadiagonal        #
! #                                                         #
! ###########################################################

! #############################################################
! #                                                           #
! #   This Version of LIDORT-2STREAM comes with a GNU-style   #
! #   license. Please read the license carefully.             #
! #                                                           #
! #############################################################

! ###########################################################
! #                                                         #
! #   Contains the following Master subroutines             #
! #                                                         #
! #          TWOSTREAM_UPUSER_PROFILEWF   (master)          #
! #          TWOSTREAM_DNUSER_PROFILEWF   (master)          #
! #          TWOSTREAM_FLUXES_PROFILEWF. 11/5/13 Version 2p3#
! #          TWOSTREAM_LPS_CONVERGE (master)                #
! #          TWOSTREAM_LPS_CONVERGE_OBSGEO (master)         #
! #                                                         #
! ###########################################################

module twostream_lp_jacobians_m

PUBLIC

contains

SUBROUTINE TWOSTREAM_UPUSER_PROFILEWF &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,            & ! Dimensions
         DO_INCLUDE_SURFACE, DO_BRDF_SURFACE, DO_USER_OBSGEOMS,          & ! inputs !@@ 2p1 
         DO_SOLAR_SOURCES, DO_INCLUDE_THERMEMISS, DO_2S_LEVELOUT,        & ! inputs !@@ 2p2
         FOURIER_COMPONENT, IPARTIC, NLAYERS,                            & ! input
         N_USER_STREAMS, VARIATION_INDEX, K_PARAMETERS, PI4,             & ! input
         FLUX_MULTIPLIER, SURFACE_FACTOR, ALBEDO, UBRDF_F, STREAM_VALUE, & ! input
         T_DELT_EIGEN, T_DELT_USERM, L_T_DELT_EIGEN, L_T_DELT_USERM,     & ! input
         L_XPOS, L_XNEG, L_WLOWER, LCON, MCON, NCON, PCON, LCON_XVEC,    & ! input
         NCON_XVEC, PCON_XVEC, U_XPOS, U_XNEG, U_WPOS2, L_U_XPOS,        & ! input
         L_U_XNEG, LP_U_WPOS2, HMULT_1, HMULT_2, EMULT_UP, CUMSOURCE_UP, & ! input
         L_HMULT_1, L_HMULT_2, LP_EMULT_UP, L_LAYER_TSUP_UP,             & ! input
         PROFILEWF_F_UP, PROFJACLEVEL_F_UP )                               ! Output !@@ 2p2

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  Subroutine input arguments
!  --------------------------

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  local control flags

      LOGICAL, INTENT(IN)  :: DO_INCLUDE_SURFACE
      LOGICAL, INTENT(IN)  :: DO_BRDF_SURFACE

!   !@@ Observational Geometry flag !@@ 2p1

      LOGICAL, INTENT(IN)        :: DO_USER_OBSGEOMS !@@ 2p1

!  Local source flags

      LOGICAL, INTENT(IN)        :: DO_SOLAR_SOURCES
      LOGICAL, INTENT(IN)        :: DO_INCLUDE_THERMEMISS

!     ! @@ Rob Spurr, 17 July 2013, Version 2.2, Levelout flag

      LOGICAL, INTENT(IN)        :: DO_2S_LEVELOUT

!  Fourier component, beam index

      INTEGER, INTENT(IN)  :: FOURIER_COMPONENT
      INTEGER, INTENT(IN)  :: IPARTIC

!  Numbers

      INTEGER, INTENT(IN)  :: NLAYERS, N_USER_STREAMS

!  multiplier, 4pi

      REAL(kind=dp), INTENT(IN)  :: FLUX_MULTIPLIER, PI4

!  Linearization control

      INTEGER      , INTENT(IN)  :: VARIATION_INDEX, K_PARAMETERS

!  Surface stuff

      REAL(kind=dp), INTENT(IN)  :: SURFACE_FACTOR, ALBEDO
      REAL(kind=dp), INTENT(IN)  :: UBRDF_F ( 0:1, MAX_USER_STREAMS )

!  Direct-beam contributions, not required
!      REAL(kind=dp), INTENT(IN)  :: USER_DIRECT_BEAM(MAX_USER_STREAMS,MAXBEAMS)
!      REAL(kind=dp), INTENT(IN)  :: CHAPMAN_FACTORS ( MAXLAYERS, MAXLAYERS, MAXBEAMS )      REAL(kind=dp), INTENT(IN)  :: L_DELTAU_VERT(MAXLAYERS,MAX_ATMOSWFS)

!  transmittance factors for +/- eigenvalues

      REAL(kind=dp), INTENT(IN)  :: T_DELT_EIGEN  (MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_EIGEN(MAXLAYERS,MAX_ATMOSWFS)

!  Transmittance factors for user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: T_DELT_USERM   (MAXLAYERS,MAX_USER_STREAMS)
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM (MAXLAYERS,MAX_USER_STREAMS,MAX_ATMOSWFS)

!  Stream value

      REAL(kind=dp), INTENT(IN)  :: STREAM_VALUE

!  Eigenvector solutions

      REAL(kind=dp), INTENT(IN)  :: L_XPOS(2,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: L_XNEG(2,MAXLAYERS,MAX_ATMOSWFS)

!  Solution constants of integration

      REAL(kind=dp), INTENT(IN)  :: LCON(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: MCON(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: NCON(MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: PCON(MAXLAYERS,MAX_ATMOSWFS)

!  Solution constants of integration multiplied by homogeneous solutions

      REAL(kind=dp), INTENT(IN)  :: LCON_XVEC(2,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: NCON_XVEC(2,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: PCON_XVEC(2,MAXLAYERS,MAX_ATMOSWFS)

!  General beam solutions at the Upper/Lower boundary

      REAL(kind=dp), INTENT(IN)  :: L_WLOWER(2,MAXLAYERS,MAX_ATMOSWFS)

!  Eigenvectors defined at user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: U_XPOS(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: U_XNEG(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: L_U_XPOS(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: L_U_XNEG(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Diffuse-term Particular beam solutions at user-defined angles

      REAL(kind=dp), INTENT(IN)  :: U_WPOS2(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: LP_U_WPOS2(MAX_USER_STREAMS,MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

!  Single-scatter Particular beam solutions at user-defined angles
!    ****** NOT REQUIRED for MS-mode only
!      REAL(kind=dp), INTENT(IN)  :: U_WPOS1(MAX_USER_STREAMS,MAXLAYERS)
!      REAL(kind=dp), INTENT(IN)  :: LP_U_WPOS1(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  solution multipliers 

      REAL(kind=dp), INTENT(IN)  :: HMULT_1(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: HMULT_2(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: EMULT_UP(MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)

      REAL(kind=dp), INTENT(IN)  :: L_HMULT_1(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: L_HMULT_2(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: LP_EMULT_UP(MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Cumulative source terms

      REAL(kind=dp), INTENT(IN)  :: CUMSOURCE_UP(MAX_USER_STREAMS,0:MAXLAYERS)

!  Thermal layer source term

      REAL(kind=dp), INTENT(IN)  :: L_LAYER_TSUP_UP(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Outputs
!  -------

!  User-defined Jacobians, Fourier component

      REAL(kind=dp), INTENT(INOUT) :: PROFILEWF_F_UP(MAX_USER_STREAMS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Fourier-component solutions at ALL levels
!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

      REAL(kind=dp), INTENT(INOUT) :: PROFJACLEVEL_F_UP (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

!  local variables
!  ---------------

!  BOA source terms
!    MS mode only, do not require direct beam source terms

      REAL(kind=dp) :: L_BOA_MSSOURCE ( MAX_USER_STREAMS, MAX_ATMOSWFS )

!  Reflectance integrand  a(j).x(j).I(-j)

      REAL(kind=dp) :: L_IDOWN(MAX_ATMOSWFS)

!  Local layer and cumulative source terms

      REAL(kind=dp) :: L_LAYERSOURCE ( MAX_USER_STREAMS, MAX_ATMOSWFS )
      REAL(kind=dp) :: L_CUMULSOURCE ( MAX_USER_STREAMS, MAX_ATMOSWFS )

!  help variables

      LOGICAL       :: LUOGSS
      INTEGER       :: UM, N, N1, NC, Q, K, IB, M, LUM
      REAL(kind=dp) :: SFOR2, H1, H2, H3, H4, H5, H6, SPAR, TM
      REAL(kind=dp) :: LCON_UXVEC, MCON_UXVEC
      REAL(kind=dp) :: NCON_UXVEC, PCON_UXVEC, KMULT, KMULT_0

!  indices

      K   = VARIATION_INDEX
      IB  = IPARTIC
      M   = FOURIER_COMPONENT

!  Local user index !@@ 2p1,  bservation Geometry choice, 12/21/12
!  Local user flag  !@@ 2p1, Observation Geometry choice, 12/21/12

      LUM    = 1
      LUOGSS = DO_USER_OBSGEOMS .and. DO_SOLAR_SOURCES

!  Zero all Fourier components - New rule, better for safety
!    Only did this for components close to zenith (formerly)
!            !@@ 2p1, New OBSGEOM option 12/21/12
!            !@@ 2p2, Zero the new "All-level" output (Already Pre-zeroed in LCS FOURIER MASTER)

      IF ( LUOGSS ) THEN
        DO Q = 1, K_PARAMETERS
          PROFILEWF_F_UP(LUM,IB,K,Q)  = 0.0d0
        ENDDO
      ELSE
        DO UM = 1, N_USER_STREAMS
          DO Q = 1, K_PARAMETERS
            PROFILEWF_F_UP(UM,IB,K,Q) = 0.0d0
          ENDDO
        ENDDO
      ENDIF

!  BOA source terms
!  ----------------

!  initialise boa source terms
!    MS mode only, do not require direct beam source terms
!         !@@ 2p1, New OBSGEOM option 12/21/12

      IF ( LUOGSS ) THEN
        DO Q = 1, K_PARAMETERS
          L_BOA_MSSOURCE(IB,Q) = 0.0d0
        ENDDO
      ELSE
        DO UM = 1, N_USER_STREAMS
          DO Q = 1, K_PARAMETERS
            L_BOA_MSSOURCE(UM,Q) = 0.0d0
          ENDDO
        ENDDO
      ENDIF

!  Surface Calculation, multiple scatter intensity at user defined-angles
!   --Update to include BRDF stuff.............
!         !@@ 2p1, New OBSGEOM option 12/21/12

      IF ( DO_INCLUDE_SURFACE )THEN
         N = NLAYERS
         KMULT_0 = SURFACE_FACTOR * STREAM_VALUE
         DO Q = 1, K_PARAMETERS
            SPAR = 0.0_dp
            IF ( K.EQ.N ) THEN
               SPAR = L_WLOWER(1,N,Q)      ! Always exists solar or thermal or both
               H1   = NCON_XVEC(1,N,Q) * T_DELT_EIGEN(N)
               H2   = LCON_XVEC(1,N) * L_T_DELT_EIGEN(N,Q)
               H3   = LCON(N)*T_DELT_EIGEN(N)*L_XPOS(1,N,Q)
               H4   = PCON_XVEC(1,N,Q)
               H5   = MCON(N) * L_XNEG(1,N,Q)
               L_IDOWN(Q) = SPAR + H1 + H2 + H3 + H4 + H5
            ELSE IF (K.LT.N.AND.K.NE.0) THEN
               IF ( DO_SOLAR_SOURCES ) SPAR = L_WLOWER(1,N,Q)  ! Only exists solar
               H1 = NCON_XVEC(1,N,Q) * T_DELT_EIGEN(N)
               H2 = PCON_XVEC(1,N,Q) 
               L_IDOWN(Q) = SPAR + H1 + H2
            ENDIF
            IF ( DO_BRDF_SURFACE ) THEN
               KMULT = KMULT_0 * L_IDOWN(Q)
               IF ( LUOGSS ) THEN
                  L_BOA_MSSOURCE(IB,Q) = KMULT * UBRDF_F(M,IB)
               ELSE
                  DO UM = 1, N_USER_STREAMS
                     L_BOA_MSSOURCE(UM,Q) = KMULT * UBRDF_F(M,UM)
                  ENDDO
               ENDIF
            ELSE
               KMULT = KMULT_0 * ALBEDO * L_IDOWN(Q)
               IF ( LUOGSS ) THEN
                  L_BOA_MSSOURCE(IB,Q) = KMULT
               ELSE
                  DO UM = 1, N_USER_STREAMS
                     L_BOA_MSSOURCE(UM,Q) = KMULT
                  ENDDO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

!  Initialize post-processing recursion
!  ====================================

!  Set the cumulative source term equal to BOA values
!     No Direct-beam contribution, MS-mode only
!         !@@ 2p1, New OBSGEOM option 12/21/12
!         !@@ 2p2, Set All-level output at surface

      NC = 0
      IF ( LUOGSS ) THEN
        DO Q = 1, K_PARAMETERS
          L_CUMULSOURCE(IB,Q) = L_BOA_MSSOURCE(IB,Q) 
          if ( DO_2S_LEVELOUT ) PROFJACLEVEL_F_UP(LUM,IB,NLAYERS,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(IB,Q)
        ENDDO
      ELSE
        DO UM = 1, N_USER_STREAMS
          DO Q = 1, K_PARAMETERS
            L_CUMULSOURCE(UM,Q) = L_BOA_MSSOURCE(UM,Q) 
            if ( DO_2S_LEVELOUT ) PROFJACLEVEL_F_UP(UM,IB,NLAYERS,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(UM,Q)
          ENDDO
        ENDDO
      ENDIF

!  Recursion Loop in Source function integration
!  =============================================

      DO N = NLAYERS, 1, -1
        NC = NLAYERS + 1 - N ; N1 = N - 1

!  Homogeneous: Special case when N = K
!  Other cases when N not equal to K (only variation of Integ-Cons)
!         !@@ 2p1, New OBSGEOM option 12/21/12

        IF ( LUOGSS ) THEN
           IF ( N.EQ.K ) THEN
              LCON_UXVEC = LCON(N) * U_XPOS(IB,N)
              MCON_UXVEC = MCON(N) * U_XNEG(IB,N)
              DO Q = 1, K_PARAMETERS
                 NCON_UXVEC = NCON(N,Q) * U_XPOS(IB,N)
                 PCON_UXVEC = PCON(N,Q) * U_XNEG(IB,N)
                 H1 = LCON_UXVEC * L_HMULT_2(IB,N,Q)
                 H2 = NCON_UXVEC *   HMULT_2(IB,N)
                 H3 = LCON(N)*L_U_XPOS(IB,N,Q)*HMULT_2(IB,N)
                 H4 = MCON_UXVEC * L_HMULT_1(IB,N,Q)
                 H5 = PCON_UXVEC *   HMULT_1(IB,N)
                 H6 = MCON(N)*L_U_XNEG(IB,N,Q)*HMULT_1(IB,N)
                 L_LAYERSOURCE(IB,Q) = H1 + H2 + H3 + H4 + H5 + H6
              ENDDO
           ELSE IF ( N.NE.K  ) THEN
              DO Q = 1, K_PARAMETERS
                 NCON_UXVEC = NCON(N,Q) * U_XPOS(IB,N)
                 PCON_UXVEC = PCON(N,Q) * U_XNEG(IB,N)
                 H2 = NCON_UXVEC * HMULT_2(IB,N)
                 H5 = PCON_UXVEC * HMULT_1(IB,N)
                 L_LAYERSOURCE(IB,Q) = H2 + H5
              ENDDO
           ENDIF
        ELSE
          IF ( N.EQ.K ) THEN
            DO UM = 1, N_USER_STREAMS
              LCON_UXVEC = LCON(N) * U_XPOS(UM,N)
              MCON_UXVEC = MCON(N) * U_XNEG(UM,N)
              DO Q = 1, K_PARAMETERS
                NCON_UXVEC = NCON(N,Q) * U_XPOS(UM,N)
                PCON_UXVEC = PCON(N,Q) * U_XNEG(UM,N)
                H1 = LCON_UXVEC * L_HMULT_2(UM,N,Q)
                H2 = NCON_UXVEC *   HMULT_2(UM,N)
                H3 = LCON(N)*L_U_XPOS(UM,N,Q)*HMULT_2(UM,N)
                H4 = MCON_UXVEC * L_HMULT_1(UM,N,Q)
                H5 = PCON_UXVEC *   HMULT_1(UM,N)
                H6 = MCON(N)*L_U_XNEG(UM,N,Q)*HMULT_1(UM,N)
                L_LAYERSOURCE(UM,Q) = H1 + H2 + H3 + H4 + H5 + H6
              ENDDO
            ENDDO
          ELSE IF ( N.NE.K  ) THEN
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                NCON_UXVEC = NCON(N,Q) * U_XPOS(UM,N)
                PCON_UXVEC = PCON(N,Q) * U_XNEG(UM,N)
                H2 = NCON_UXVEC * HMULT_2(UM,N)
                H5 = PCON_UXVEC * HMULT_1(UM,N)
                L_LAYERSOURCE(UM,Q) = H2 + H5
              ENDDO
            ENDDO
          ENDIF
        ENDIF

!  Add thermal emission term (direct and diffuse)
!     -----Modulus 1 if solar sources are included (taken care of earlier)
!     ----- Linearization only exists if N = K
!         !@@ 2p1, New OBSGEOM option 12/21/12

        IF ( DO_INCLUDE_THERMEMISS ) THEN
          TM = 1.0_dp ; IF ( DO_SOLAR_SOURCES ) TM = 1.0_dp/PI4
          IF ( LUOGSS ) THEN
            IF ( N.EQ.K ) THEN
              DO Q = 1, K_PARAMETERS
                L_LAYERSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q) + L_LAYER_TSUP_UP(IB,N,Q)*TM
              ENDDO
            ENDIF
          ELSE
            IF ( N.EQ.K ) THEN
              DO UM = 1, N_USER_STREAMS
                DO Q = 1, K_PARAMETERS
                  L_LAYERSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q) + L_LAYER_TSUP_UP(UM,N,Q)*TM
                ENDDO
              ENDDO
            ENDIF
          ENDIF
        ENDIF

!  nothing more to do if no solar sources

        IF ( .NOT. DO_SOLAR_SOURCES ) GO TO 5445

!  Particular Integral, Diffuse contribution term
!     Either : Particular for  N = K
!     Or     : Particular for N > K (profile only)
!         !@@ 2p1, New OBSGEOM option 12/21/12

        IF ( N.EQ.K ) THEN
          IF ( LUOGSS ) THEN
            DO Q = 1, K_PARAMETERS
              SFOR2 = LP_EMULT_UP(LUM,N,IB,K,Q) *    U_WPOS2(IB,N) &
                       + EMULT_UP(LUM,N,IB)     * LP_U_WPOS2(IB,N,K,Q)
              L_LAYERSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q) + SFOR2 
            ENDDO
          ELSE
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                SFOR2 = LP_EMULT_UP(UM,N,IB,K,Q) *    U_WPOS2(UM,N) &
                         + EMULT_UP(UM,N,IB)     * LP_U_WPOS2(UM,N,K,Q)
                L_LAYERSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q) + SFOR2 
              ENDDO
            ENDDO
          ENDIF
        ELSE IF ( N.GT.K ) THEN
          IF ( LUOGSS ) THEN
            DO Q = 1, K_PARAMETERS
              SFOR2 = LP_EMULT_UP(LUM,N,IB,K,Q) *    U_WPOS2(IB,N) &
                       + EMULT_UP(LUM,N,IB)     * LP_U_WPOS2(IB,N,K,Q)
              L_LAYERSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q) + SFOR2 
            ENDDO
          ELSE
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                SFOR2 = LP_EMULT_UP(UM,N,IB,K,Q) *    U_WPOS2(UM,N) &
                         + EMULT_UP(UM,N,IB)     * LP_U_WPOS2(UM,N,K,Q)
                L_LAYERSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q) + SFOR2 
              ENDDO
           ENDDO
          ENDIF
        ENDIF

!  Continuation point

5445    continue

!  Add to Linearized cumulative source sterm
!         !@@ 2p1, New OBSGEOM option 12/21/12
!         !@@ 2p2, Set All-level outputs, 7/17/13

        IF ( LUOGSS ) THEN
          IF ( N.EQ.K ) THEN
            DO Q = 1, K_PARAMETERS
              L_CUMULSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q)         + &
                     T_DELT_USERM(N,IB)*L_CUMULSOURCE(IB,Q)     + &
                   L_T_DELT_USERM(N,IB,Q)*CUMSOURCE_UP(IB,NC-1)
              if (DO_2S_LEVELOUT)PROFJACLEVEL_F_UP(LUM,IB,N1,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(IB,Q)
            ENDDO
          ELSE IF ( N.NE.K ) THEN
            DO Q = 1, K_PARAMETERS
              L_CUMULSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q)  + &
                   T_DELT_USERM(N,IB)*L_CUMULSOURCE(IB,Q)
              if (DO_2S_LEVELOUT)PROFJACLEVEL_F_UP(LUM,IB,N1,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(IB,Q)
            ENDDO
          ENDIF
        ELSE
          IF ( N.EQ.K ) THEN
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                L_CUMULSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q)         + &
                       T_DELT_USERM(N,UM)*L_CUMULSOURCE(UM,Q)     + &
                     L_T_DELT_USERM(N,UM,Q)*CUMSOURCE_UP(UM,NC-1)
                if (DO_2S_LEVELOUT)PROFJACLEVEL_F_UP(UM,IB,N1,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(UM,Q)
              ENDDO
            ENDDO
          ELSE IF ( N.NE.K ) THEN
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                L_CUMULSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q)  + &
                     T_DELT_USERM(N,UM)*L_CUMULSOURCE(UM,Q)
                if (DO_2S_LEVELOUT)PROFJACLEVEL_F_UP(UM,IB,N1,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(UM,Q)
              ENDDO
            ENDDO
          ENDIF
        ENDIF

!  End layer loop

      ENDDO

!  User-defined stream output, just set to the cumulative source term
!         !@@ 2p1, New OBSGEOM option 12/21/12

      IF ( LUOGSS ) THEN
        DO Q = 1, K_PARAMETERS
          PROFILEWF_F_UP(LUM,IPARTIC,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(IB,Q)
        ENDDO
      ELSE
        DO UM = 1, N_USER_STREAMS
          DO Q = 1, K_PARAMETERS
            PROFILEWF_F_UP(UM,IPARTIC,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(UM,Q)
          ENDDO
        ENDDO
      ENDIF

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_UPUSER_PROFILEWF

!

SUBROUTINE TWOSTREAM_DNUSER_PROFILEWF &
      ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,       & ! Dimensions
        DO_INCLUDE_THERMEMISS, DO_SOLAR_SOURCES,                   & ! Dimensions
        DO_USER_OBSGEOMS, DO_2S_LEVELOUT,                          & ! Inputs !@@ 2p1, 2p2
        FOURIER_COMPONENT, IPARTIC, NLAYERS,                       & ! input
        N_USER_STREAMS, VARIATION_INDEX, K_PARAMETERS,             & ! input
        PI4, FLUX_MULTIPLIER, T_DELT_USERM, L_T_DELT_USERM,        & ! input
        LCON, MCON, NCON, PCON, U_XPOS, U_XNEG, U_WNEG2,           & ! input
        L_U_XPOS, L_U_XNEG, LP_U_WNEG2, HMULT_1, HMULT_2,          & ! input
        EMULT_DN, CUMSOURCE_DN, L_HMULT_1, L_HMULT_2,              & ! input
        LP_EMULT_DN, L_LAYER_TSUP_DN,                              & ! input
        PROFILEWF_F_DN, PROFJACLEVEL_F_DN )                          ! Output !@@ 2p2

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  Subroutine input arguments
!  --------------------------

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Local source flags

      LOGICAL, INTENT(IN)        :: DO_SOLAR_SOURCES
      LOGICAL, INTENT(IN)        :: DO_INCLUDE_THERMEMISS

!   !@@ 2p1, Observational Geometry flag

      LOGICAL, INTENT(IN)        :: DO_USER_OBSGEOMS !@@ 2p1

!     ! @@ Rob Spurr, 17 July 2013, Version 2.2, Levelout flag

      LOGICAL, INTENT(IN)        :: DO_2S_LEVELOUT

!  Fourier component

      INTEGER, INTENT(IN)  :: FOURIER_COMPONENT

!   @@@@@@@@@ not required (MS-mode only) @@@@@@@@@@@@@@@@
!      LOGICAL, INTENT(IN)  :: DO_MSMODE_LIDORT

!  beam index

      INTEGER, INTENT(IN)  :: IPARTIC

!  Numbers

      INTEGER, INTENT(IN)  :: NLAYERS, N_USER_STREAMS

!  Linearization control

      INTEGER, INTENT(IN)  :: VARIATION_INDEX, K_PARAMETERS

!  multiplier, 4pi

      REAL(kind=dp), INTENT(IN)  :: FLUX_MULTIPLIER, PI4

!  Transmittance factors for user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: T_DELT_USERM   (MAXLAYERS,MAX_USER_STREAMS)
      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM (MAXLAYERS,MAX_USER_STREAMS,MAX_ATMOSWFS)

!  Solution constants of integration

      REAL(kind=dp), INTENT(IN)  :: LCON(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: MCON(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: NCON(MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: PCON(MAXLAYERS,MAX_ATMOSWFS)

!  Eigenvectors defined at user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: U_XPOS(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: U_XNEG(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: L_U_XPOS(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: L_U_XNEG(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Diffuse-term Particular beam solutions at user-defined angles

      REAL(kind=dp), INTENT(IN)  :: U_WNEG2(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: LP_U_WNEG2(MAX_USER_STREAMS,MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

! Single-scatter Particular beam solutions at user-defined angles
!    ****** NOT REQUIRED for MS-mode only
!      REAL(kind=dp), INTENT(IN)  :: U_WNEG1(MAX_USER_STREAMS,MAXLAYERS)
!      REAL(kind=dp), INTENT(IN)  :: LP_U_WNEG1(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  solution multipliers 

      REAL(kind=dp), INTENT(IN)  :: HMULT_1(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: HMULT_2(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: EMULT_DN(MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS)

      REAL(kind=dp), INTENT(IN)  :: L_HMULT_1(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: L_HMULT_2(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: LP_EMULT_DN(MAX_USER_STREAMS,MAXLAYERS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Cumulative source terms

      REAL(kind=dp), INTENT(IN)  :: CUMSOURCE_DN(MAX_USER_STREAMS,0:MAXLAYERS)

!  Thermal layer source term

      REAL(kind=dp), INTENT(IN)  :: L_LAYER_TSUP_DN(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Outputs
!  -------

!  User-defined Jacobians, Fourier component

      REAL(kind=dp), INTENT(INOUT) :: PROFILEWF_F_DN (MAX_USER_STREAMS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Fourier-component solutions at ALL levels
!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

      REAL(kind=dp), INTENT(INOUT) :: PROFJACLEVEL_F_DN (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

!  local variables
!  ---------------

!  Local layer and cumulative source terms

      REAL(kind=dp) :: L_LAYERSOURCE ( MAX_USER_STREAMS, MAX_ATMOSWFS )
      REAL(kind=dp) :: L_CUMULSOURCE ( MAX_USER_STREAMS, MAX_ATMOSWFS )

!  Help variables

      LOGICAL       :: LUOGSS
      INTEGER       :: UM, N, NC, Q, K, IB, M, LUM
      REAL(kind=dp) :: SFOR2, H1, H2, H3, H4, H5, H6, TM
      REAL(kind=dp) :: LCON_UXVEC, MCON_UXVEC, NCON_UXVEC, PCON_UXVEC

!  indices

      K   = VARIATION_INDEX
      IB  = IPARTIC
      M   = FOURIER_COMPONENT

!  Local user index !@@ 2p1,  bservation Geometry choice, 12/21/12
!  Local user flag  !@@ 2p1, Observation Geometry choice, 12/21/12

      LUM    = 1
      LUOGSS = DO_USER_OBSGEOMS .and. DO_SOLAR_SOURCES

!  Zero all Fourier components - New rule, better for safety
!    Only did this for components close to zenith (formerly)
!            !@@ 2p1, New OBSGEOM option 12/21/12
!            !@@ 2p2, Zero the new "All-level" output (Already Pre-zeroed in LCS FOURIER MASTER)

      IF ( LUOGSS ) THEN
        DO Q = 1, K_PARAMETERS
          PROFILEWF_F_DN(LUM,IPARTIC,K,Q)  = 0.0d0
        ENDDO
      ELSE
        DO UM = 1, N_USER_STREAMS
          DO Q = 1, K_PARAMETERS
            PROFILEWF_F_DN(UM,IPARTIC,K,Q) = 0.0d0
          ENDDO
        ENDDO
      ENDIF

!  Set the cumulative source term equal to TOA values
!         !@@ 2p1, New OBSGEOM option 12/21/12

      NC = 0
      IF ( LUOGSS ) THEN
        DO Q = 1, K_PARAMETERS
          L_CUMULSOURCE(IB,Q) = 0.0d0 
        ENDDO
      ELSE
        DO UM = 1, N_USER_STREAMS
          DO Q = 1, K_PARAMETERS
            L_CUMULSOURCE(UM,Q) = 0.0d0
          ENDDO
        ENDDO
      ENDIF

!  Cumulative source terms to layer NUT (user-defined stream angles only)
!    1. Get layer source terms
!    2. Find cumulative source term

      DO N = 1, NLAYERS
        NC = N

!  Homogeneous: Special case when N = K
!  Other cases when N not equal to K (only variation of Integ-Cons)
!         !@@ 2p1, New OBSGEOM option 12/21/12

        IF ( LUOGSS ) THEN
           IF ( N.EQ.K ) THEN
              LCON_UXVEC = LCON(N) * U_XNEG(IB,N)
              MCON_UXVEC = MCON(N) * U_XPOS(IB,N)
              DO Q = 1, K_PARAMETERS
                 NCON_UXVEC = NCON(N,Q) * U_XNEG(IB,N)
                 PCON_UXVEC = PCON(N,Q) * U_XPOS(IB,N)
                 H1 = LCON_UXVEC * L_HMULT_1(IB,N,Q)
                 H2 = NCON_UXVEC *   HMULT_1(IB,N)
                 H3 = LCON(N)*L_U_XNEG(IB,N,Q)*HMULT_1(IB,N)
                 H4 = MCON_UXVEC * L_HMULT_2(IB,N,Q)
                 H5 = PCON_UXVEC *   HMULT_2(IB,N)
                 H6 = MCON(N)*L_U_XPOS(IB,N,Q)*HMULT_2(IB,N)
                 L_LAYERSOURCE(IB,Q) = H1 + H2 + H3 + H4 + H5 + H6
              ENDDO
           ELSE IF ( N.NE.K ) THEN
              DO Q = 1, K_PARAMETERS
                 NCON_UXVEC = NCON(N,Q) * U_XNEG(IB,N)
                 PCON_UXVEC = PCON(N,Q) * U_XPOS(IB,N)
                 H2 = NCON_UXVEC * HMULT_1(IB,N)
                 H5 = PCON_UXVEC * HMULT_2(IB,N)
                 L_LAYERSOURCE(IB,Q) = H2 + H5
              ENDDO
           ENDIF
        ELSE
          IF ( N.EQ.K ) THEN
            DO UM = 1, N_USER_STREAMS
              LCON_UXVEC = LCON(N) * U_XNEG(UM,N)
              MCON_UXVEC = MCON(N) * U_XPOS(UM,N)
              DO Q = 1, K_PARAMETERS
                NCON_UXVEC = NCON(N,Q) * U_XNEG(UM,N)
                PCON_UXVEC = PCON(N,Q) * U_XPOS(UM,N)
                H1 = LCON_UXVEC * L_HMULT_1(UM,N,Q)
                H2 = NCON_UXVEC *   HMULT_1(UM,N)
                H3 = LCON(N)*L_U_XNEG(UM,N,Q)*HMULT_1(UM,N)
                H4 = MCON_UXVEC * L_HMULT_2(UM,N,Q)
                H5 = PCON_UXVEC *   HMULT_2(UM,N)
                H6 = MCON(N)*L_U_XPOS(UM,N,Q)*HMULT_2(UM,N)
                L_LAYERSOURCE(UM,Q) = H1 + H2 + H3 + H4 + H5 + H6
              ENDDO
            ENDDO
          ELSE IF ( N.NE.K ) THEN
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                NCON_UXVEC = NCON(N,Q) * U_XNEG(UM,N)
                PCON_UXVEC = PCON(N,Q) * U_XPOS(UM,N)
                H2 = NCON_UXVEC * HMULT_1(UM,N)
                H5 = PCON_UXVEC * HMULT_2(UM,N)
                L_LAYERSOURCE(UM,Q) = H2 + H5
              ENDDO
            ENDDO
          ENDIF
        ENDIF

!  Add thermal emission term (direct and diffuse)
!     ----- Modulus 1 if solar sources are included (taken care of earlier)
!     ----- Linearization only exists if N = K,
!         !@@ 2p1, New OBSGEOM option 12/21/12

        IF ( DO_INCLUDE_THERMEMISS ) THEN
          TM = 1.0_dp ; IF ( DO_SOLAR_SOURCES ) TM = 1.0_dp/PI4
          IF ( LUOGSS ) THEN
            IF ( N.EQ.K ) THEN
              DO Q = 1, K_PARAMETERS
                L_LAYERSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q) + L_LAYER_TSUP_DN(IB,N,Q)*TM
              ENDDO
            ENDIF
          ELSE
            IF ( N.EQ.K ) THEN
              DO UM = 1, N_USER_STREAMS
                DO Q = 1, K_PARAMETERS
                  L_LAYERSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q) + L_LAYER_TSUP_DN(UM,N,Q)*TM
                ENDDO
              ENDDO
            ENDIF
          ENDIF
        ENDIF

!  nothing more to do if no solar sources

        IF ( .NOT. DO_SOLAR_SOURCES ) GO TO 6556

!  Particular Integral, Diffuse contribution term
!     Either : Particular for  N = K
!     Or     : Particular for N > K (profile only)

!         !@@ 2p1, New OBSGEOM option 12/21/12

        IF ( LUOGSS ) THEN
          IF ( N.EQ.K ) THEN
            DO Q = 1, K_PARAMETERS
              SFOR2 = LP_EMULT_DN(LUM,N,IB,K,Q) *    U_WNEG2(IB,N)  &
                       + EMULT_DN(LUM,N,IB)     * LP_U_WNEG2(IB,N,K,Q)
              L_LAYERSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q) + SFOR2
            ENDDO
          ELSE IF ( N.GT.K ) THEN
            DO Q = 1, K_PARAMETERS
              SFOR2 = LP_EMULT_DN(LUM,N,IB,K,Q) *    U_WNEG2(IB,N)  &
                       + EMULT_DN(LUM,N,IB)     * LP_U_WNEG2(IB,N,K,Q)
              L_LAYERSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q) + SFOR2
            ENDDO
          ENDIF
        ELSE
          IF ( N.EQ.K ) THEN
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                SFOR2 = LP_EMULT_DN(UM,N,IB,K,Q) *    U_WNEG2(UM,N)  &
                         + EMULT_DN(UM,N,IB)     * LP_U_WNEG2(UM,N,K,Q)
                L_LAYERSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q) + SFOR2
              ENDDO
            ENDDO
          ELSE IF ( N.GT.K ) THEN
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                SFOR2 = LP_EMULT_DN(UM,N,IB,K,Q) *   U_WNEG2(UM,N)  &
                        + EMULT_DN(UM,N,IB)     * LP_U_WNEG2(UM,N,K,Q)
                L_LAYERSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q) + SFOR2
              ENDDO
            ENDDO
          ENDIF
        ENDIF

!  Continuation point

6556    continue

!  Add to Linearized cumulative source sterm
!         !@@ 2p1, New OBSGEOM option 12/21/12
!         !@@ 2p2, Set All-level outputs, 7/17/13

        IF ( LUOGSS ) THEN
          IF ( N.EQ.K ) THEN
            DO Q = 1, K_PARAMETERS
              L_CUMULSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q)         + &
                     T_DELT_USERM(N,IB)*L_CUMULSOURCE(IB,Q)     + &
                   L_T_DELT_USERM(N,IB,Q)*CUMSOURCE_DN(IB,NC-1)
              if (DO_2S_LEVELOUT)PROFJACLEVEL_F_DN(LUM,IB,N,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(IB,Q)
            ENDDO
          ELSE IF ( N.NE.K ) THEN
            DO Q = 1, K_PARAMETERS
              L_CUMULSOURCE(IB,Q) = L_LAYERSOURCE(IB,Q)  + &
                   T_DELT_USERM(N,IB)*L_CUMULSOURCE(IB,Q)
              if (DO_2S_LEVELOUT)PROFJACLEVEL_F_DN(LUM,IB,N,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(IB,Q)
            ENDDO
          ENDIF
        ELSE
          IF ( N.EQ.K ) THEN
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                L_CUMULSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q)    + &
                      T_DELT_USERM(N,UM)*L_CUMULSOURCE(UM,Q) + &
                    L_T_DELT_USERM(N,UM,Q)*CUMSOURCE_DN(UM,NC-1)
                if (DO_2S_LEVELOUT)PROFJACLEVEL_F_DN(UM,IB,N,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(UM,Q)
              ENDDO
            ENDDO
          ELSE IF ( N.NE.K.AND.K.NE.0 ) THEN
            DO UM = 1, N_USER_STREAMS
              DO Q = 1, K_PARAMETERS
                L_CUMULSOURCE(UM,Q) = L_LAYERSOURCE(UM,Q)  + &
                     T_DELT_USERM(N,UM)*L_CUMULSOURCE(UM,Q)
                if (DO_2S_LEVELOUT)PROFJACLEVEL_F_DN(UM,IB,N,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(UM,Q)
              ENDDO
            ENDDO
          ENDIF
        ENDIF

!  End layer loop

      ENDDO

!  User-defined stream output, just set to the cumulative source term
!         !@@ 2p1, New OBSGEOM option 12/21/12

      IF ( LUOGSS ) THEN
        DO Q = 1, K_PARAMETERS
          PROFILEWF_F_DN(LUM,IPARTIC,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(IB,Q)
        ENDDO
      ELSE
        DO UM = 1, N_USER_STREAMS
          DO Q = 1, K_PARAMETERS
            PROFILEWF_F_DN(UM,IPARTIC,K,Q) = FLUX_MULTIPLIER * L_CUMULSOURCE(UM,Q)
          ENDDO
        ENDDO
      ENDIF

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_DNUSER_PROFILEWF

!

SUBROUTINE TWOSTREAM_FLUXES_PROFILEWF &
            ( MAXBEAMS, MAXLAYERS, MAX_ATMOSWFS, MAXTHREADS,      & ! Dimensions
              DO_UPWELLING, DO_DNWELLING, IBEAM, NLAYERS, THREAD, & ! Input flags/Control
              NV, NVARY, PI4, STREAM_VALUE, FLUX_MULTIPLIER,      & ! Input Control
              LCON, MCON, LCON_XVEC, MCON_XVEC,                   & ! Input 2-stream solution
              NCON_XVEC, PCON_XVEC, L_XPOS, L_XNEG,               & ! Input 2-stream solution Linearized
              EIGENTRANS, L_EIGENTRANS, L_WUPPER, L_WLOWER,       & ! Input 2-stream solution linearized
              PROFJACFLUXES_TOA, PROFJACFLUXES_BOA )                ! Output

!  New routine 11/5/13. Diffuse Fluxes at TOA and BOA

      implicit none

!  Precision

      INTEGER, PARAMETER :: dp = KIND( 1.0D0 )

!  Input variables
!  ---------------

!  Dimensions (2p2, add MAXLAYERS)

      INTEGER, INTENT(IN)        :: MAXBEAMS, MAXTHREADS, MAXLAYERS, MAX_ATMOSWFS

!  Control

      LOGICAL, INTENT(IN)        :: DO_UPWELLING, DO_DNWELLING

!  Thread, beam, nlayers

      INTEGER, INTENT(IN)        :: NLAYERS, THREAD, IBEAM

!  Number of weighting functions and layer to vary

      INTEGER, INTENT(IN)        :: NV, NVARY

!  multiplier, 4pi

      REAL(kind=dp), INTENT(IN)  :: FLUX_MULTIPLIER, PI4

!  Stream value

      REAL(kind=dp), INTENT(IN)  :: STREAM_VALUE

!  Eigenvector solutions

      REAL(kind=dp), INTENT(IN)  :: L_XPOS(2,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: L_XNEG(2,MAXLAYERS,MAX_ATMOSWFS)

!  Solution constants of integration

      REAL(kind=dp), INTENT(IN)  :: LCON(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: MCON(MAXLAYERS)

!  Solution constants of integration multiplied by homogeneous solutions

      REAL(kind=dp), INTENT(IN)  :: LCON_XVEC(2,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: MCON_XVEC(2,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: NCON_XVEC(2,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: PCON_XVEC(2,MAXLAYERS,MAX_ATMOSWFS)

!  General beam solutions at the Upper/Lower boundary

      REAL(kind=dp), INTENT(IN)  :: L_WUPPER(2,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: L_WLOWER(2,MAXLAYERS,MAX_ATMOSWFS)

!  Eigen-Transmittance

      REAL(kind=dp), INTENT(IN) :: EIGENTRANS(MAXLAYERS)
      REAL(kind=dp), INTENT(IN) :: L_EIGENTRANS(MAXLAYERS,MAX_ATMOSWFS)


!  Flux output (already initialized here)
!     ! @@ Rob Spurr, 05 November 2013, Version 2.3 --> Flux Output

      REAL(kind=dp), INTENT(INOUT) :: PROFJACFLUXES_TOA(MAXBEAMS,2,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: PROFJACFLUXES_BOA(MAXBEAMS,2,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)

!  Local variables

      INTEGER       :: N, Q
      REAL(kind=dp) :: PI2, SPI2, HOM1, HOM2, HOM3, HOM4, HOM5
      REAL(kind=dp) :: SHOM, SPAR, LP_QUADINTENS_TOA, LP_QUADINTENS_BOA

!  Constants

      PI2 = 0.5d0 * PI4 ; SPI2 = PI2 * STREAM_VALUE

!  upwelling Flux at TOA

      if ( DO_UPWELLING ) THEN
         N = 1
         DO Q = 1, NVARY
            IF ( NV.eq.N ) THEN
              HOM1 = NCON_XVEC(2,N,Q) 
              HOM2 = LCON(N) * L_XPOS(2,N,Q)
              HOM3 = MCON_XVEC(2,N) * L_EIGENTRANS(N,Q)
              HOM4 = MCON(N) * EIGENTRANS(N) * L_XNEG(2,N,Q)
              HOM5 = PCON_XVEC(2,N,Q) * EIGENTRANS(N)
              SHOM = HOM1 + HOM2 + HOM3 + HOM4 + HOM5
              SPAR = L_WUPPER(2,N,Q)
            ELSE
              HOM1 = NCON_XVEC(2,N,Q) 
              HOM2 = PCON_XVEC(2,N,Q) * EIGENTRANS(N)
              SHOM = HOM1 + HOM2
            ENDIF
            SPAR = L_WUPPER(2,N,Q)
!mick fix 12/17/2013 - fixed typo for LP_QUADINTENS_TOA: BOA -> TOA
            LP_QUADINTENS_TOA = FLUX_MULTIPLIER * ( SPAR + SHOM )
            PROFJACFLUXES_TOA(IBEAM,1,NV,Q,THREAD) = 0.5d0 * LP_QUADINTENS_TOA
            PROFJACFLUXES_TOA(IBEAM,2,NV,Q,THREAD) = SPI2  * LP_QUADINTENS_TOA
         ENDDO
      endif

!  Downwelling Flux at BOA

      if ( DO_DNWELLING ) THEN
         N = NLAYERS
         DO Q = 1, NVARY
            IF ( NV.eq.N ) THEN
              HOM1 = NCON_XVEC(1,N,Q) * EIGENTRANS(N)
              HOM2 = LCON_XVEC(1,N)   * L_EIGENTRANS(N,Q)
              HOM3 = LCON(N) * EIGENTRANS(N) * L_XPOS(1,N,Q)
              HOM4 = PCON_XVEC(1,N,Q)
              HOM5 = MCON(N) * L_XNEG(1,N,Q)
              SHOM = HOM1 + HOM2 + HOM3 + HOM4 + HOM5
            ELSE
              HOM1 = NCON_XVEC(1,N,Q) * EIGENTRANS(N)
              HOM2 = PCON_XVEC(1,N,Q)
              SHOM = HOM1 + HOM2
            ENDIF
            SPAR = L_WLOWER(1,N,Q)
            LP_QUADINTENS_BOA = FLUX_MULTIPLIER * ( SPAR + SHOM )
            PROFJACFLUXES_BOA(IBEAM,1,NV,Q,THREAD) = 0.5d0 * LP_QUADINTENS_BOA
            PROFJACFLUXES_BOA(IBEAM,2,NV,Q,THREAD) = SPI2  * LP_QUADINTENS_BOA
         ENDDO
      endif

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_FLUXES_PROFILEWF

!

SUBROUTINE TWOSTREAM_LPS_CONVERGE &
      ( MAXBEAMS, MAX_USER_STREAMS, MAX_USER_RELAZMS, MAX_GEOMETRIES,                & ! Dimensions
        MAXTHREADS, MAXLAYERS, MAX_ATMOSWFS, MAX_SURFACEWFS,                         & ! Dimensions ! @@ 2p2
        DO_UPWELLING, DO_DNWELLING, DO_2S_LEVELOUT, DO_M1_SURFACE, DO_TSURFACE_WFS,  & ! Inputs     ! @@ 2p2
        LAYER_VARY_FLAG, LAYER_VARY_NUMBER, N_TSURFACE_WFS, NLAYERS, THREAD,         & ! Inputs
        IBEAM, FOURIER, N_USER_STREAMS, N_USER_RELAZMS, AZMFAC, UMOFF,               & ! Inputs
        PROFILEWF_F_UP,  PROFILEWF_F_DN, PROFJACLEVEL_F_UP, PROFJACLEVEL_F_DN,       & ! Inputs     ! @@ 2p2
        SURFACEWF_F_UP,  SURFACEWF_F_DN, SURFJACLEVEL_F_UP, SURFJACLEVEL_F_DN,       & ! Inputs     ! @@ 2p2
        PROFILEWF_TOA,   PROFILEWF_BOA,  PROFJACLEVEL_UP,   PROFJACLEVEL_DN,         & ! In/Out     ! @@ 2p2
        SURFACEWF_TOA,   SURFACEWF_BOA,  SURFJACLEVEL_UP,   SURFJACLEVEL_DN  )         ! In/Out     ! @@ 2p2

!  Alterations for version 2.2, 17 July 2013

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  input variables
!  ---------------

!  Dimensions (2p2, add MAXLAYERS)

      INTEGER, INTENT(IN)  :: MAXBEAMS, MAX_USER_STREAMS, MAX_USER_RELAZMS, MAX_GEOMETRIES
      INTEGER, INTENT(IN)  :: MAXTHREADS, MAXLAYERS, MAX_ATMOSWFS, MAX_SURFACEWFS

!  Control
!     ! @@ Rob Spurr, 17 July 2013, Version 2.2, Levelout flag

      LOGICAL, INTENT(IN)  :: DO_UPWELLING, DO_DNWELLING
      LOGICAL, INTENT(IN)  :: DO_2S_LEVELOUT
      LOGICAL, INTENT(IN)  :: DO_M1_SURFACE


!  SS control, not required in this streamlined version
!      LOGICAL, INTENT(IN)  :: DO_SSFULL, DO_SSCORR_OUTGOING, DO_SSCORR_NADIR

!  Linearization control

      LOGICAL, INTENT(IN)  :: DO_TSURFACE_WFS

!  Numbers

      INTEGER, INTENT(IN)  :: N_USER_STREAMS, N_USER_RELAZMS

!  Fourier component and thread, beam, nlayers (2p2, added)

      INTEGER, INTENT(IN)  :: FOURIER, THREAD, IBEAM, NLAYERS

!  Local linearization control

      LOGICAL, INTENT(IN)  :: LAYER_VARY_FLAG   ( MAXLAYERS )
      INTEGER, INTENT(IN)  :: LAYER_VARY_NUMBER ( MAXLAYERS )
      INTEGER, INTENT(IN)  :: N_TSURFACE_WFS

!  Local  azimuth factors

      INTEGER, INTENT(IN)        :: UMOFF ( MAXBEAMS, MAX_USER_STREAMS )
      REAL(kind=dp), INTENT(IN)  :: AZMFAC(MAX_USER_STREAMS,MAXBEAMS,MAX_USER_RELAZMS)

!  User-defined solutions

      REAL(kind=dp), INTENT(IN)  :: PROFILEWF_F_UP(MAX_USER_STREAMS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: PROFILEWF_F_DN(MAX_USER_STREAMS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

      REAL(kind=dp), INTENT(IN)  :: SURFACEWF_F_UP(MAX_USER_STREAMS,MAXBEAMS,MAX_SURFACEWFS)
      REAL(kind=dp), INTENT(IN)  :: SURFACEWF_F_DN(MAX_USER_STREAMS,MAXBEAMS,MAX_SURFACEWFS)

!  Fourier-component solutions at ALL levels
!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

      REAL(kind=dp), INTENT(IN) :: PROFJACLEVEL_F_UP (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN) :: PROFJACLEVEL_F_DN (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

      REAL(kind=dp), INTENT(IN) :: SURFJACLEVEL_F_UP (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAX_SURFACEWFS)
      REAL(kind=dp), INTENT(IN) :: SURFJACLEVEL_F_DN (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAX_SURFACEWFS)

!  Single scatter solutions
!    Commented out in this streamlined version
!      REAL(kind=dp), INTENT(IN)  :: PROFILEWF_SS_UP(MAX_GEOMETRIES,MAXLAYERS,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(IN)  :: PROFILEWF_SS_DN(MAX_GEOMETRIES,MAXLAYERS,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(IN)  :: COLUMNWF_SS_UP(MAX_GEOMETRIES,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(IN)  :: COLUMNWF_SS_DN(MAX_GEOMETRIES,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(IN)  :: SURFACEWF_DB(MAX_GEOMETRIES,MAXSPARS)

!  Output
!  ------

      REAL(kind=dp), INTENT(INOUT) :: PROFILEWF_TOA(MAX_GEOMETRIES,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: PROFILEWF_BOA(MAX_GEOMETRIES,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)

      REAL(kind=dp), INTENT(INOUT) :: SURFACEWF_TOA(MAX_GEOMETRIES,MAX_SURFACEWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: SURFACEWF_BOA(MAX_GEOMETRIES,MAX_SURFACEWFS,MAXTHREADS)

!  output solutions at ALL levels
!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

      REAL(kind=dp), INTENT(INOUT) :: PROFJACLEVEL_UP (MAX_GEOMETRIES,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: PROFJACLEVEL_DN (MAX_GEOMETRIES,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)

      REAL(kind=dp), INTENT(INOUT) :: SURFJACLEVEL_UP (MAX_GEOMETRIES,0:MAXLAYERS,MAX_SURFACEWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: SURFJACLEVEL_DN (MAX_GEOMETRIES,0:MAXLAYERS,MAX_SURFACEWFS,MAXTHREADS)

!  local variables
!  ---------------

      INTEGER       :: I, UA, V, Q, Z, N
      REAL(kind=dp) :: TOLD, TAZM

!  ###################
!  Fourier 0 component
!  ###################

      IF ( FOURIER.EQ.0 ) THEN

!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

!  Profile atmospheric weighting functions
!  ---------------------------------------

!  Diffuse field at all output angles

         DO N = 1, NLAYERS
          IF ( LAYER_VARY_FLAG(N) ) THEN
           DO Q = 1, LAYER_VARY_NUMBER(N)
            DO I = 1, N_USER_STREAMS
             DO UA = 1, N_USER_RELAZMS
              V = UMOFF(IBEAM,I) + UA
              IF ( DO_UPWELLING ) THEN
               PROFILEWF_TOA(V,N,Q,THREAD) = PROFILEWF_F_UP(I,IBEAM,N,Q)
               IF ( DO_2S_LEVELOUT ) PROFJACLEVEL_UP(V,0:NLAYERS,N,Q,THREAD) = PROFJACLEVEL_F_UP(I,IBEAM,0:NLAYERS,N,Q)
              ENDIF
              IF ( DO_DNWELLING ) THEN
               PROFILEWF_BOA(V,N,Q,THREAD) = PROFILEWF_F_DN(I,IBEAM,N,Q)
               IF ( DO_2S_LEVELOUT ) PROFJACLEVEL_DN(V,0:NLAYERS,N,Q,THREAD) = PROFJACLEVEL_F_DN(I,IBEAM,0:NLAYERS,N,Q)
              ENDIF
             ENDDO
            ENDDO
           ENDDO
          ENDIF
         ENDDO
        
!  TOTAL Surface weighting functions
!  ---------------------------------

       IF ( DO_TSURFACE_WFS ) THEN
          DO Z = 1, N_TSURFACE_WFS
             DO I = 1, N_USER_STREAMS
                DO UA = 1, N_USER_RELAZMS
                   V = UMOFF(IBEAM,I) + UA
                   IF ( DO_UPWELLING ) THEN
                      SURFACEWF_TOA(V,Z,THREAD) = SURFACEWF_F_UP(I,IBEAM,Z)
                      IF ( DO_2S_LEVELOUT ) SURFJACLEVEL_UP(V,0:NLAYERS,Z,THREAD) = SURFJACLEVEL_F_UP(I,IBEAM,0:NLAYERS,Z)
                   ENDIF
                   IF ( DO_DNWELLING ) THEN
                      SURFACEWF_BOA(V,Z,THREAD) = SURFACEWF_F_DN(I,IBEAM,Z)
                      IF ( DO_2S_LEVELOUT ) SURFJACLEVEL_DN(V,0:NLAYERS,Z,THREAD) = SURFJACLEVEL_F_DN(I,IBEAM,0:NLAYERS,Z)
                   ENDIF
                ENDDO
             ENDDO
          ENDDO
       ENDIF

!  ######################
!  Fourier component = 1
!  ######################

      ELSE

!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

!  Profile atmospheric weighting functions
!  ---------------------------------------

        DO N = 1, NLAYERS
         IF ( LAYER_VARY_FLAG(N) ) THEN
          DO Q = 1, LAYER_VARY_NUMBER(N)
           DO UA = 1, N_USER_RELAZMS
            DO I = 1, N_USER_STREAMS
             V = UMOFF(IBEAM,I) + UA
             IF ( DO_UPWELLING ) THEN
              TOLD = PROFILEWF_TOA(V,N,Q,THREAD)
              TAZM = AZMFAC(I,IBEAM,UA)*PROFILEWF_F_UP(I,IBEAM,N,Q)
              PROFILEWF_TOA(V,N,Q,THREAD) = TOLD + TAZM
              IF ( DO_2S_LEVELOUT ) PROFJACLEVEL_UP(V,0:NLAYERS,N,Q,THREAD) = &
                   PROFJACLEVEL_UP(V,0:NLAYERS,N,Q,THREAD) + AZMFAC(I,IBEAM,UA) * PROFJACLEVEL_F_UP(I,IBEAM,0:NLAYERS,N,Q)
             ENDIF
             IF ( DO_DNWELLING ) THEN
              TOLD = PROFILEWF_BOA(V,N,Q,THREAD)
              TAZM = AZMFAC(I,IBEAM,UA)*PROFILEWF_F_DN(I,IBEAM,N,Q)
              PROFILEWF_BOA(V,N,Q,THREAD) = TOLD + TAZM
              IF ( DO_2S_LEVELOUT ) PROFJACLEVEL_DN(V,0:NLAYERS,N,Q,THREAD) = &
                   PROFJACLEVEL_DN(V,0:NLAYERS,N,Q,THREAD) + AZMFAC(I,IBEAM,UA) * PROFJACLEVEL_F_DN(I,IBEAM,0:NLAYERS,N,Q)
             ENDIF
            ENDDO
           ENDDO
          ENDDO
         ENDIF
        ENDDO

!  TOTAL Surface weighting functions
!  ---------------------------------

!  Version 2p3: only for NON-LAMBERTIAN Surface or NON-ISOTROPIC Sleave)

       IF ( DO_TSURFACE_WFS .and. DO_M1_SURFACE ) THEN
          DO Z = 1, N_TSURFACE_WFS
            DO I = 1, N_USER_STREAMS
              DO UA = 1, N_USER_RELAZMS
                V = UMOFF(IBEAM,I) + UA
                IF ( DO_UPWELLING ) THEN
                  TOLD = SURFACEWF_TOA(V,Z,THREAD)
                  TAZM = AZMFAC(I,IBEAM,UA)*SURFACEWF_F_UP(I,IBEAM,Z)
                  SURFACEWF_TOA(V,Z,THREAD) = TOLD + TAZM
                  IF ( DO_2S_LEVELOUT ) SURFJACLEVEL_UP(V,0:NLAYERS,Z,THREAD) = &
                    SURFJACLEVEL_UP(V,0:NLAYERS,Z,THREAD) + AZMFAC(I,IBEAM,UA) * SURFJACLEVEL_F_UP(I,IBEAM,0:NLAYERS,Z)
                ENDIF
                IF ( DO_DNWELLING ) THEN
                  TOLD = SURFACEWF_BOA(V,Z,THREAD)
                  TAZM = AZMFAC(I,IBEAM,UA)*SURFACEWF_F_DN(I,IBEAM,Z)
                  SURFACEWF_BOA(V,Z,THREAD) = TOLD + TAZM
                  IF ( DO_2S_LEVELOUT ) SURFJACLEVEL_DN(V,0:NLAYERS,Z,THREAD) = &
                    SURFJACLEVEL_DN(V,0:NLAYERS,Z,THREAD) + AZMFAC(I,IBEAM,UA) * SURFJACLEVEL_F_DN(I,IBEAM,0:NLAYERS,Z)
                ENDIF
              ENDDO
            ENDDO
          ENDDO
       ENDIF

!  Finish Fourier

      ENDIF

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LPS_CONVERGE

!

SUBROUTINE TWOSTREAM_LPS_CONVERGE_OBSGEO &
      ( MAXBEAMS, MAX_USER_STREAMS, MAX_USER_RELAZMS, MAX_GEOMETRIES,                & ! Dimensions
        MAXTHREADS, MAXLAYERS, MAX_ATMOSWFS, MAX_SURFACEWFS,                         & ! Dimensions ! @@ 2p2
        DO_UPWELLING, DO_DNWELLING, DO_2S_LEVELOUT, DO_M1_SURFACE, DO_TSURFACE_WFS,  & ! Inputs     ! @@ 2p2
        LAYER_VARY_FLAG, LAYER_VARY_NUMBER, N_TSURFACE_WFS,                          & ! Inputs
        NLAYERS, THREAD, IBEAM, FOURIER, AZMFAC,                                     & ! Inputs
        PROFILEWF_F_UP,  PROFILEWF_F_DN, PROFJACLEVEL_F_UP, PROFJACLEVEL_F_DN,       & ! Inputs     ! @@ 2p2
        SURFACEWF_F_UP,  SURFACEWF_F_DN, SURFJACLEVEL_F_UP, SURFJACLEVEL_F_DN,       & ! Inputs     ! @@ 2p2
        PROFILEWF_TOA,   PROFILEWF_BOA,  PROFJACLEVEL_UP,   PROFJACLEVEL_DN,         & ! In/Out     ! @@ 2p2
        SURFACEWF_TOA,   SURFACEWF_BOA,  SURFJACLEVEL_UP,   SURFJACLEVEL_DN  )         ! In/Out     ! @@ 2p2

!  Alterations for version 2.2, 17 July 2013

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  input variables
!  ---------------

!  Dimensions (2p2, add MAXLAYERS)

      INTEGER, INTENT(IN)  :: MAXBEAMS, MAX_USER_STREAMS, MAX_USER_RELAZMS, MAX_GEOMETRIES
      INTEGER, INTENT(IN)  :: MAXTHREADS, MAXLAYERS, MAX_ATMOSWFS, MAX_SURFACEWFS

!  Control
!     ! @@ Rob Spurr, 17 July 2013, Version 2.2, Levelout flag

      LOGICAL, INTENT(IN)  :: DO_UPWELLING, DO_DNWELLING
      LOGICAL, INTENT(IN)  :: DO_2S_LEVELOUT
      LOGICAL, INTENT(IN)  :: DO_M1_SURFACE

!  SS control, not required in this streamlined version
!      LOGICAL, INTENT(IN)  :: DO_SSFULL, DO_SSCORR_OUTGOING, DO_SSCORR_NADIR

!  Linearization control

      LOGICAL, INTENT(IN)  :: DO_TSURFACE_WFS

!  Fourier component and thread, beam, nlayers (2p2, added)

      INTEGER, INTENT(IN)  :: FOURIER, THREAD, IBEAM, NLAYERS

!  Local linearization control

      LOGICAL, INTENT(IN)  :: LAYER_VARY_FLAG   ( MAXLAYERS )
      INTEGER, INTENT(IN)  :: LAYER_VARY_NUMBER ( MAXLAYERS )
      INTEGER, INTENT(IN)  :: N_TSURFACE_WFS

!  Local  azimuth factors

      REAL(kind=dp), INTENT(IN)  :: AZMFAC(MAX_USER_STREAMS,MAXBEAMS,MAX_USER_RELAZMS)

!  User-defined solutions

      REAL(kind=dp), INTENT(IN)  :: PROFILEWF_F_UP(MAX_USER_STREAMS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: PROFILEWF_F_DN(MAX_USER_STREAMS,MAXBEAMS,MAXLAYERS,MAX_ATMOSWFS)

      REAL(kind=dp), INTENT(IN)  :: SURFACEWF_F_UP(MAX_USER_STREAMS,MAXBEAMS,MAX_SURFACEWFS)
      REAL(kind=dp), INTENT(IN)  :: SURFACEWF_F_DN(MAX_USER_STREAMS,MAXBEAMS,MAX_SURFACEWFS)

!  Fourier-component solutions at ALL levels
!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

      REAL(kind=dp), INTENT(IN) :: PROFJACLEVEL_F_UP (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN) :: PROFJACLEVEL_F_DN (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS)

      REAL(kind=dp), INTENT(IN) :: SURFJACLEVEL_F_UP (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAX_SURFACEWFS)
      REAL(kind=dp), INTENT(IN) :: SURFJACLEVEL_F_DN (MAX_USER_STREAMS,MAXBEAMS,0:MAXLAYERS,MAX_SURFACEWFS)

!  Single scatter solutions
!    Commented out in this streamlined version
!      REAL(kind=dp), INTENT(IN)  :: PROFILEWF_SS_UP(MAX_GEOMETRIES,MAXLAYERS,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(IN)  :: PROFILEWF_SS_DN(MAX_GEOMETRIES,MAXLAYERS,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(IN)  :: COLUMNWF_SS_UP(MAX_GEOMETRIES,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(IN)  :: COLUMNWF_SS_DN(MAX_GEOMETRIES,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(IN)  :: SURFACEWF_DB(MAX_GEOMETRIES,MAXSPARS)

!  Output
!  ------

      REAL(kind=dp), INTENT(INOUT) :: PROFILEWF_TOA(MAX_GEOMETRIES,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: PROFILEWF_BOA(MAX_GEOMETRIES,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)

      REAL(kind=dp), INTENT(INOUT) :: SURFACEWF_TOA(MAX_GEOMETRIES,MAX_SURFACEWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: SURFACEWF_BOA(MAX_GEOMETRIES,MAX_SURFACEWFS,MAXTHREADS)

!  output solutions at ALL levels
!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

      REAL(kind=dp), INTENT(INOUT) :: PROFJACLEVEL_UP (MAX_GEOMETRIES,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: PROFJACLEVEL_DN (MAX_GEOMETRIES,0:MAXLAYERS,MAXLAYERS,MAX_ATMOSWFS,MAXTHREADS)

      REAL(kind=dp), INTENT(INOUT) :: SURFJACLEVEL_UP (MAX_GEOMETRIES,0:MAXLAYERS,MAX_SURFACEWFS,MAXTHREADS)
      REAL(kind=dp), INTENT(INOUT) :: SURFJACLEVEL_DN (MAX_GEOMETRIES,0:MAXLAYERS,MAX_SURFACEWFS,MAXTHREADS)

!  local variables
!  ---------------

      INTEGER       :: Q, Z, N, LUM, LUA
      REAL(kind=dp) :: TOLD, AZFAC

!  Local user indices

      LUM = 1
      LUA = 1

      AZFAC = AZMFAC(LUM,IBEAM,LUA)

!  ###################
!  Fourier 0 component
!  ###################

      IF ( FOURIER.EQ.0 ) THEN

!  Profile atmospheric weighting functions
!  ---------------------------------------

!  Copy DIFFUSE Fourier component at all output angles

        DO N = 1, NLAYERS
          IF ( LAYER_VARY_FLAG(N) ) THEN
            DO Q = 1, LAYER_VARY_NUMBER(N)
              IF ( DO_UPWELLING ) THEN
                PROFILEWF_TOA(IBEAM,N,Q,THREAD) = PROFILEWF_F_UP(LUM,IBEAM,N,Q)
                IF ( DO_2S_LEVELOUT ) PROFJACLEVEL_UP(IBEAM,0:NLAYERS,N,Q,THREAD) = PROFJACLEVEL_F_UP(LUM,IBEAM,0:NLAYERS,N,Q)
              ENDIF
              IF ( DO_DNWELLING ) THEN
                PROFILEWF_BOA(IBEAM,N,Q,THREAD) = PROFILEWF_F_DN(LUM,IBEAM,N,Q)
                IF ( DO_2S_LEVELOUT ) PROFJACLEVEL_DN(IBEAM,0:NLAYERS,N,Q,THREAD) = PROFJACLEVEL_F_DN(LUM,IBEAM,0:NLAYERS,N,Q)
              ENDIF
            ENDDO
          ENDIF
        ENDDO

!  TOTAL Surface weighting functions
!  ---------------------------------

       IF ( DO_TSURFACE_WFS ) THEN
          DO Z = 1, N_TSURFACE_WFS
             IF ( DO_UPWELLING ) THEN
                SURFACEWF_TOA(IBEAM,Z,THREAD) = SURFACEWF_F_UP(LUM,IBEAM,Z)
                IF ( DO_2S_LEVELOUT ) SURFJACLEVEL_UP(IBEAM,0:NLAYERS,Z,THREAD) = SURFJACLEVEL_F_UP(LUM,IBEAM,0:NLAYERS,Z)
             ENDIF
             IF ( DO_DNWELLING ) THEN
                SURFACEWF_BOA(IBEAM,Z,THREAD) = SURFACEWF_F_DN(LUM,IBEAM,Z)
                IF ( DO_2S_LEVELOUT ) SURFJACLEVEL_DN(IBEAM,0:NLAYERS,Z,THREAD) = SURFJACLEVEL_F_DN(LUM,IBEAM,0:NLAYERS,Z)
             ENDIF
          ENDDO
       ENDIF

!  ######################
!  Fourier component = 1
!  ######################

      ELSE

!     ! @@ Rob Spurr, 17 July 2013, Version 2.2 --> Optional Output at ALL LEVELS

!  Profile atmospheric weighting functions
!  ---------------------------------------

        DO N = 1, NLAYERS
          IF ( LAYER_VARY_FLAG(N) ) THEN
            DO Q = 1, LAYER_VARY_NUMBER(N)
              IF ( DO_UPWELLING ) THEN
                TOLD = PROFILEWF_TOA(IBEAM,N,Q,THREAD)
                PROFILEWF_TOA(IBEAM,N,Q,THREAD) = TOLD + AZFAC*PROFILEWF_F_UP(LUM,IBEAM,N,Q)
                IF ( DO_2S_LEVELOUT ) PROFJACLEVEL_UP(IBEAM,0:NLAYERS,N,Q,THREAD) = &
                   PROFJACLEVEL_UP(IBEAM,0:NLAYERS,N,Q,THREAD) + AZFAC * PROFJACLEVEL_F_UP(LUM,IBEAM,0:NLAYERS,N,Q)
              ENDIF
              IF ( DO_DNWELLING ) THEN
                TOLD = PROFILEWF_BOA(IBEAM,N,Q,THREAD)
                PROFILEWF_BOA(IBEAM,N,Q,THREAD) = TOLD + AZFAC*PROFILEWF_F_DN(LUM,IBEAM,N,Q)
                IF ( DO_2S_LEVELOUT ) PROFJACLEVEL_DN(IBEAM,0:NLAYERS,N,Q,THREAD) = &
                   PROFJACLEVEL_DN(IBEAM,0:NLAYERS,N,Q,THREAD) + AZFAC * PROFJACLEVEL_F_DN(LUM,IBEAM,0:NLAYERS,N,Q)
              ENDIF
            ENDDO
          ENDIF
        ENDDO

!  TOTAL Surface weighting functions
!  ---------------------------------

!  Version 2p3: only for NON-LAMBERTIAN Surface or NON-ISOTROPIC Sleave)

       IF ( DO_TSURFACE_WFS .and. DO_M1_SURFACE ) THEN
          DO Z = 1, N_TSURFACE_WFS
             IF ( DO_UPWELLING ) THEN
                TOLD = SURFACEWF_TOA(IBEAM,Z,THREAD)
                SURFACEWF_TOA(IBEAM,Z,THREAD) = TOLD + AZFAC * SURFACEWF_F_UP(LUM,IBEAM,Z)
                IF ( DO_2S_LEVELOUT ) SURFJACLEVEL_UP(IBEAM,0:NLAYERS,Z,THREAD) = &
                      SURFJACLEVEL_UP(IBEAM,0:NLAYERS,Z,THREAD) + AZFAC * SURFJACLEVEL_F_UP(LUM,IBEAM,0:NLAYERS,Z)
             ENDIF
             IF ( DO_DNWELLING ) THEN
                TOLD = SURFACEWF_BOA(IBEAM,Z,THREAD)
                SURFACEWF_BOA(IBEAM,Z,THREAD) = TOLD + AZFAC * SURFACEWF_F_DN(LUM,IBEAM,Z)
                IF ( DO_2S_LEVELOUT ) SURFJACLEVEL_DN(IBEAM,0:NLAYERS,Z,THREAD) = &
                      SURFJACLEVEL_DN(IBEAM,0:NLAYERS,Z,THREAD) + AZFAC * SURFJACLEVEL_F_DN(LUM,IBEAM,0:NLAYERS,Z)
             ENDIF
          ENDDO
       ENDIF

!  Finish Fourier

      ENDIF

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LPS_CONVERGE_OBSGEO

end module twostream_lp_jacobians_m
