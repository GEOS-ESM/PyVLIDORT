! ###########################################################
! #                                                         #
! #             THE TWOSTREAM LIDORT MODEL                  #
! #                                                         #
! #      (LInearized Discrete Ordinate Radiative Transfer)  #
! #       --         -        -        -         -          #
! #                                                         #
! ###########################################################

! ###########################################################
! #                                                         #
! #  Authors :      Robert. J. D. Spurr (1)                 #
! #                 Vijay Natraj        (2)                 #
! #                                                         #
! #  Address (1) :     RT Solutions, Inc.                   #
! #                    9 Channing Street                    #
! #                    Cambridge, MA 02138, USA             #
! #  Tel:             (617) 492 1183                        #
! #  Email :           rtsolutions@verizon.net              #
! #                                                         #
! #  Address (2) :     CalTech                              #
! #                    Department of Planetary Sciences     #
! #                    1200 East California Boulevard       #
! #                    Pasadena, CA 91125                   #
! #  Tel:             (626) 395 6962                        #
! #  Email :           vijay@gps.caltech.edu                #
! #                                                         #
! #  Version 1.0-1.3 :                                      #
! #     Mark 1: October  2010                               #
! #     Mark 2: May      2011, with BRDFs                   #
! #     Mark 3: October  2011, with Thermal sources         #
! #                                                         #
! #  Version 2.0-2.1 :                                      #
! #     Mark 4: November 2012, LCS/LPS Split, Fixed Arrays  #
! #     Mark 5: December 2012, Observation Geometry option  #
! #                                                         #
! #  Version 2.2-2.3 :                                      #
! #     Mark 6: July     2013, Level outputs + control      #
! #     Mark 7: December 2013, Flux outputs  + control      #
! #     Mark 8: January  2014, Surface Leaving + control    #
! #     Mark 9: June     2014, Inverse Pentadiagonal        #
! #                                                         #
! ###########################################################

! #############################################################
! #                                                           #
! #   This Version of LIDORT-2STREAM comes with a GNU-style   #
! #   license. Please read the license carefully.             #
! #                                                           #
! #############################################################

! ###############################################################
! #                                                             #
! # Subroutines in this Module                                  #
! #                                                             #
! #     Homogeneous solution                                    #
! #                                                             #
! #              TWOSTREAM_L_HOM_SOLUTION                       #
! #              TWOSTREAM_L_HOM_USERSOLUTION                   #
! #              TWOSTREAM_L_HMULT_MASTER                       #
! #                                                             #
! ###############################################################

module twostream_la_solutions_m

PUBLIC

contains

SUBROUTINE TWOSTREAM_L_HOM_SOLUTION &
         ( MAXLAYERS, MAX_ATMOSWFS,                       & ! Dimensions
           N, FOURIER, DOVARY, NVARY,                     & ! Input
           STREAM_VALUE, PXSQ, OMEGA, ASYMM, DELTAU_VERT, & ! Input
           L_OMEGA, L_ASYMM, L_DELTAU_VERT,               & ! Input
           SAB, DAB, EIGENVALUE, EIGENTRANS,              & ! Input
           L_EIGENVALUE, L_EIGENTRANS,                    & ! In/Out
           L_SAB, L_DAB, L_XPOS, L_XNEG )                   ! In/Out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  subroutine input arguments
!  --------------------------

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAX_ATMOSWFS

!  Given layer index and Fourier number (inputs)

      INTEGER, INTENT(IN)  :: N
      INTEGER, INTENT(IN)  :: FOURIER

!  Linearization control

      LOGICAL, INTENT(IN)  :: DOVARY
      INTEGER, INTENT(IN)  :: NVARY

!  Stream value

      REAL(kind=dp), INTENT(IN)  :: STREAM_VALUE

!  Legendre input

      REAL(kind=dp), INTENT(IN)  :: PXSQ

!  OMEGA and ASYMM and linearizations

      REAL(kind=dp), INTENT(IN)  :: OMEGA   ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: ASYMM   ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_OMEGA ( MAXLAYERS, MAX_ATMOSWFS  )
      REAL(kind=dp), INTENT(IN)  :: L_ASYMM ( MAXLAYERS, MAX_ATMOSWFS  )

!  optical thickness and its linearizations

      REAL(kind=dp), INTENT(IN)  :: DELTAU_VERT   ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_DELTAU_VERT ( MAXLAYERS, MAX_ATMOSWFS )

!  local matrices for eigenvalue computation

      REAL(kind=dp), INTENT(IN)  :: SAB(MAXLAYERS), DAB(MAXLAYERS)

!  Eigensolutions

      REAL(kind=dp), INTENT(IN)  :: EIGENVALUE(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: EIGENTRANS(MAXLAYERS)

!  Output arguments
!  ----------------

!  Eigensolutions

      REAL(kind=dp), INTENT(INOUT) :: L_EIGENVALUE(MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(INOUT) :: L_EIGENTRANS(MAXLAYERS,MAX_ATMOSWFS)

!  Linearized up and down solutions to the homogeneous RT equations

      REAL(kind=dp), INTENT(INOUT) :: L_XPOS(2,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(INOUT) :: L_XNEG(2,MAXLAYERS,MAX_ATMOSWFS)

!  Saved Linearized sum and difference terms

      REAL(kind=dp), INTENT(INOUT) :: L_SAB(MAXLAYERS,MAX_ATMOSWFS), L_DAB(MAXLAYERS,MAX_ATMOSWFS)

!  Local variables
!  ---------------

      INTEGER       :: Q
      REAL(kind=dp) :: XINV, DIFVEC, LSD, LARG
      REAL(kind=dp) :: L_OMEGA_ASYMM_3, L_DIFVEC, L_DP, L_DM

!  Initialize and return if no vary

      IF ( .NOT. DOVARY ) THEN
         DO Q = 1, NVARY
           L_DAB(N,Q)        = 0.0d0
           L_SAB(N,Q)        = 0.0d0
           L_EIGENTRANS(N,Q) = 0.0d0
           L_XPOS(1,N,Q) = 0.0d0
           L_XPOS(2,N,Q) = 0.0d0 
           L_XNEG(1,N,Q) = 0.0d0
           L_XNEG(2,N,Q) = 0.0d0 
         ENDDO
         RETURN
      ENDIF

!  Initial values

      XINV = 1.0d0 / STREAM_VALUE
      DIFVEC = - SAB(N) / EIGENVALUE(N)

!  start parameter loop

      DO Q = 1, NVARY

!  Develop Linearization of Sum and Difference matrices

        L_OMEGA_ASYMM_3 = 3.0d0 * &
          ( L_OMEGA(N,Q)*ASYMM(N) + OMEGA(N)*L_ASYMM(N,Q) )
        if ( fourier.eq.0) then
          L_DP = L_OMEGA(N,Q) + PXSQ *  L_OMEGA_ASYMM_3
          L_DM = L_OMEGA(N,Q) - PXSQ *  L_OMEGA_ASYMM_3
        Else if ( fourier .eq. 1 ) then
          L_DP = L_OMEGA_ASYMM_3 * PXSQ
          L_DM = L_OMEGA_ASYMM_3 * PXSQ
        ENDIF
        L_DAB(N,Q) = ( L_DP - L_DM ) * 0.5d0 * XINV
        L_SAB(N,Q) = ( L_DP + L_DM ) * 0.5d0 * XINV
        LSD = L_DAB(N,Q) * SAB(N) + L_SAB(N,Q) * DAB(N)    

!   Use definitions to find linearizations of eigenproblem

        L_EIGENVALUE(N,Q) = 0.5d0 * LSD / EIGENVALUE(N)
        LARG =  L_EIGENVALUE(N,Q) *   DELTAU_VERT(N) + &
                  EIGENVALUE(N)   * L_DELTAU_VERT(N,Q)
        L_EIGENTRANS(N,Q) = - LARG * EIGENTRANS(N)

!  Auxiliary equation to get up and down solutions
!   Develop linearized solutions from auxiliary Eqn. definition

        L_DIFVEC = -(DIFVEC*L_EIGENVALUE(N,Q)+L_SAB(N,Q))/EIGENVALUE(N) 
        L_XPOS(1,N,Q) = 0.5d0 * L_DIFVEC
        L_XPOS(2,N,Q) = - L_XPOS(1,N,Q) 

!  Symmetry

        L_XNEG(1,N,Q) = L_XPOS(2,N,Q)
        L_XNEG(2,N,Q) = L_XPOS(1,N,Q)

!  debug
!        if (fourier.eq.1)
!     &  write(56,'(2i4,1p3e24.12)')n,q,
!     &         L_EIGENTRANS(N,Q),EIGENTRANS(N)

! finish parameter loop

      ENDDO

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_L_HOM_SOLUTION

!

SUBROUTINE TWOSTREAM_L_HMULT_MASTER &
          ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS,          & ! DImensions
            NLAYERS, N_USER_STREAMS,                            & ! inputs
            LAYER_VARY_FLAG, LAYER_VARY_NUMBER,                 & ! inputs
            EIGENTRANS, USER_STREAMS, T_DELT_USERM,             & ! inputs
            ZETA_M, ZETA_P, HMULT_1, HMULT_2,                   & ! inputs
            L_EIGENVALUE, L_EIGENTRANS, L_T_DELT_USERM,         & ! inputs
            L_HMULT_1, L_HMULT_2 )                                ! Output

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  Input arguments
!  ===============

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Numbers

      INTEGER, INTENT(IN)  :: NLAYERS, N_USER_STREAMS

!  Linearization control

      LOGICAL, INTENT(IN)  :: LAYER_VARY_FLAG   ( MAXLAYERS )
      INTEGER, INTENT(IN)  :: LAYER_VARY_NUMBER ( MAXLAYERS )

!  User streams

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )

!  Transmittance factors for user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS )

!  Eigensolution transmittances

      REAL(kind=dp), INTENT(IN)  :: EIGENTRANS(MAXLAYERS)

!  coefficient functions for user-defined angles

      REAL(kind=dp), INTENT(IN)  :: ZETA_M(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: ZETA_P(MAX_USER_STREAMS,MAXLAYERS)

!  Integrated homogeneous solution multipliers, whole layer

      REAL(kind=dp), INTENT(IN)  :: HMULT_1(MAX_USER_STREAMS,MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: HMULT_2(MAX_USER_STREAMS,MAXLAYERS)

!  Linearized Transmittance factors for user-defined stream angles

      REAL(kind=dp), INTENT(IN)  :: L_T_DELT_USERM ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS )

!  Linearized Eigensolutions

      REAL(kind=dp), INTENT(IN)  :: L_EIGENVALUE(MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(IN)  :: L_EIGENTRANS(MAXLAYERS,MAX_ATMOSWFS)

!  Output
!  ======

!  LInearized homogeneous solution multipliers

     REAL(kind=dp), INTENT(OUT) :: L_HMULT_1(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
     REAL(kind=dp), INTENT(OUT) :: L_HMULT_2(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Local variables
!  ---------------

      INTEGER       :: Q, UM, N
      REAL(kind=dp) :: SM, L_T_1, L_T_2

!  whole layer multipliers
!  -----------------------

!  Start loops over layers and user-streams
!    Only done if layers are flagged

      DO UM = 1, N_USER_STREAMS
        SM   = 1.0d0 / USER_STREAMS(UM)
        DO N = 1, NLAYERS
         IF ( LAYER_VARY_FLAG(N) ) THEN
          DO Q = 1, LAYER_VARY_NUMBER(N)
           L_T_2 =   EIGENTRANS(N)   * L_T_DELT_USERM(N,UM,Q) + &
                   L_EIGENTRANS(N,Q) *   T_DELT_USERM(N,UM)
           L_T_1 = L_EIGENTRANS(N,Q) - L_T_DELT_USERM(N,UM,Q)
           L_HMULT_1(UM,N,Q) = ZETA_M(UM,N) * &
                 ( SM*L_T_1 + L_EIGENVALUE(N,Q)*HMULT_1(UM,N) )
           L_HMULT_2(UM,N,Q) = ZETA_P(UM,N) * &
                 ( - SM*L_T_2 - L_EIGENVALUE(N,Q)*HMULT_2(UM,N) )
          ENDDO
         ENDIF
        ENDDO
      ENDDO

!  debug
!      do n = 1, 3
!        write(56,*)L_HMULT_1(1,N,1),L_HMULT_2(1,N,1)
!      enddo

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_L_HMULT_MASTER 

!

SUBROUTINE TWOSTREAM_L_HOM_USERSOLUTION &
         ( MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS,     & ! DImensions
           N_USER_STREAMS, N, FOURIER, DOVARY, NVARY,     & ! Input
           STREAM_VALUE, PX11, USER_STREAMS, ULP, L_XPOS, & ! Input
           U_P, U_M, OMEGA, ASYMM, L_OMEGA, L_ASYMM,      & ! Input
           L_U_XPOS, L_U_XNEG )                             ! In/Out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  subroutine input arguments
!  --------------------------

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Numbers

      INTEGER, INTENT(IN)  :: N_USER_STREAMS

!  Given layer index and Fourier number (inputs)

      INTEGER, INTENT(IN)  :: N
      INTEGER, INTENT(IN)  :: FOURIER

!  Linearization control

      LOGICAL, INTENT(IN)  :: DOVARY
      INTEGER, INTENT(IN)  :: NVARY

!  Stream value and polynomial

      REAL(kind=dp), INTENT(IN)  :: STREAM_VALUE, PX11

!  User-defined post-processing stream directions

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )
      REAL(kind=dp), INTENT(IN)  :: ULP          ( MAX_USER_STREAMS )

!  OMEGA and ASYMM, + linearizations

      REAL(kind=dp), INTENT(IN)  :: OMEGA ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: ASYMM ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_OMEGA ( MAXLAYERS,MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_ASYMM ( MAXLAYERS,MAX_ATMOSWFS )

!  Linearized  eigensolutions

      REAL(kind=dp), INTENT(IN)  :: L_XPOS(2,MAXLAYERS,MAX_ATMOSWFS)

!  Saved help variables from the original routine for User solutions

      REAL(kind=dp), INTENT(IN)  :: U_P(0:1)
      REAL(kind=dp), INTENT(IN)  :: U_M(0:1)

!  Subroutine output arguments
!  ---------------------------

!  Linearized Eigensolutions defined at user-defined stream angles

      REAL(kind=dp), INTENT(INOUT) :: L_U_XPOS(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(INOUT) :: L_U_XNEG(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Local variables
!  ---------------

      INTEGER       :: UM, Q
      REAL(kind=dp) :: SUM_NEG, SUM_POS
      REAL(kind=dp) :: OMEGA_MOM, HMU_STREAM
      REAL(kind=dp) :: L_OMEGA_MOM, lu_p(0:1), lu_m(0:1)
      REAL(kind=dp) :: OM_MU, OM_ULP, L_OM_MU, L_OM_ULP
 
!  Zero output and return if no solutions

      IF ( .NOT. DOVARY ) THEN
        DO Q = 1, NVARY
          DO UM = 1, N_USER_STREAMS
            L_U_XPOS(UM,N,Q) = 0.0d0
            L_U_XNEG(UM,N,Q) = 0.0d0
          ENDDO
        ENDDO 
        RETURN
      ENDIF

!  Save some useful things

      HMU_STREAM = STREAM_VALUE *  0.5d0
      OMEGA_MOM  = 3.0d0 * OMEGA(N) * ASYMM(N)

!  Start parameter loop

      DO Q = 1, NVARY

!  basi! optical property variation

        L_OMEGA_MOM = L_OMEGA(N,Q)*ASYMM(N)+OMEGA(N)*L_ASYMM(N,Q)
        L_OMEGA_MOM = 3.0d0 * L_OMEGA_MOM

!  Eigenvector interpolation to user-defined angles
!  ------------------------------------------------

!  For each moment, do inner sum over computational angles
!  for the positive and negative eigenvectors

        if ( fourier.eq.0) then
          lu_p(0) = ( L_XPOS(2,N,Q) + L_XPOS(1,N,Q) ) * 0.5d0
          lu_p(1) = ( L_XPOS(2,N,Q) - L_XPOS(1,N,Q) ) * HMU_STREAM
          lu_M(0) =   lu_p(0)
          lu_M(1) = - lu_p(1)
        else
          lu_p(1) = - ( L_XPOS(2,N,Q) + L_XPOS(1,N,Q) ) * PX11 * 0.5d0
          lu_M(1) = lu_p(1)
        endif

!  Now sum over all harmoni! contributions at each user-defined stream

        DO UM = 1, N_USER_STREAMS
          if (fourier.eq.0 ) then
            OM_MU    =   OMEGA_MOM * USER_STREAMS(um)
            L_OM_MU  = L_OMEGA_MOM * USER_STREAMS(um)
            sum_pos = lu_p(0) *   omega(N)   + lu_p(1) *   OM_MU &
                     + u_p(0) * l_omega(N,Q) +  u_p(1) * L_OM_MU 
            sum_neg = lu_m(0) *   omega(N)   + lu_m(1) *   OM_MU &
                     + u_m(0) * l_omega(N,Q) +  u_m(1) * L_OM_MU 
          else
            OM_ULP   =   OMEGA_MOM * ulp(um)
            L_OM_ULP = L_OMEGA_MOM * ulp(um)
            sum_pos = lu_p(1) * OM_ULP + u_p(1) * L_OM_ULP
            sum_neg = lu_m(1) * OM_ULP + u_m(1) * L_OM_ULP
          endif
          L_U_XPOS(UM,N,Q) = SUM_POS
          L_U_XNEG(UM,N,Q) = SUM_NEG
        ENDDO

!  end parameter loop

      enddo

!  debug
!        if (fourier.eq.1)then
!       write(56,'(2i4,1p3e24.12)')n,1,L_U_XPOS(1,N,1),L_U_XNEG(1,N,1)
!       write(56,'(2i4,1p3e24.12)')n,2,L_U_XPOS(1,N,2),L_U_XNEG(1,N,2)
!        endif

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_L_HOM_USERSOLUTION

end module twostream_la_solutions_m
