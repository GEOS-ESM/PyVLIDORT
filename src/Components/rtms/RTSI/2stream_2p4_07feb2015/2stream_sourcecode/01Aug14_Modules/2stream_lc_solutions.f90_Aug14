! ###########################################################
! #                                                         #
! #             THE TWOSTREAM LIDORT MODEL                  #
! #                                                         #
! #      (LInearized Discrete Ordinate Radiative Transfer)  #
! #       --         -        -        -         -          #
! #                                                         #
! ###########################################################

! ###########################################################
! #                                                         #
! #  Authors :      Robert. J. D. Spurr (1)                 #
! #                 Vijay Natraj        (2)                 #
! #                                                         #
! #  Address (1) :     RT Solutions, Inc.                   #
! #                    9 Channing Street                    #
! #                    Cambridge, MA 02138, USA             #
! #  Tel:             (617) 492 1183                        #
! #  Email :           rtsolutions@verizon.net              #
! #                                                         #
! #  Address (2) :     CalTech                              #
! #                    Department of Planetary Sciences     #
! #                    1200 East California Boulevard       #
! #                    Pasadena, CA 91125                   #
! #  Tel:             (626) 395 6962                        #
! #  Email :           vijay@gps.caltech.edu                #
! #                                                         #
! #  Version 1.0-1.3 :                                      #
! #     Mark 1: October  2010                               #
! #     Mark 2: May      2011, with BRDFs                   #
! #     Mark 3: October  2011, with Thermal sources         #
! #                                                         #
! #  Version 2.0-2.1 :                                      #
! #     Mark 4: November 2012, LCS/LPS Split, Fixed Arrays  #
! #     Mark 5: December 2012, Observation Geometry option  #
! #                                                         #
! #  Version 2.2-2.3 :                                      #
! #     Mark 6: July     2013, Level outputs + control      #
! #     Mark 7: December 2013, Flux outputs  + control      #
! #     Mark 8: January  2014, Surface Leaving + control    #
! #     Mark 9: June     2014, Inverse Pentadiagonal        #
! #                                                         #
! ###########################################################

! #############################################################
! #                                                           #
! #   This Version of LIDORT-2STREAM comes with a GNU-style   #
! #   license. Please read the license carefully.             #
! #                                                           #
! #############################################################

! ###############################################################
! #                                                             #
! # Subroutines in this Module                                  #
! #                                                             #
! #     Particular integrals                                    #
! #                                                             #
! #              TWOSTREAM_LC_BEAM_SOLUTION                     #
! #              TWOSTREAM_LC_BEAM_USERSOLUTION                 #
! #                                                             #
! ###############################################################

module twostream_lc_solutions_m

PUBLIC

contains

SUBROUTINE TWOSTREAM_LC_BEAM_SOLUTION &
         ( MAXLAYERS, MAXBEAMS, MAX_ATMOSWFS,                 & ! DImensions
           DO_PLANE_PARALLEL, N, FOURIER, IBEAM, FLUX_FACTOR, & ! Input
           LAYER_PIS_CUTOFF, STREAM_VALUE, PX0X, N_COLUMN_WFS,& ! Input
           OMEGA, ASYMM, L_OMEGA, L_ASYMM,                    & ! Input
           SAB, DAB, EIGENVALUE, AVERAGE_SECANT,              & ! Input
           QSUMVEC, QDIFVEC, QVEC,                            & ! Input
           LC_AVERAGE_SECANT, L_SAB, L_DAB, L_EIGENVALUE,     & ! Input
           LC_WVEC )                                            ! In/Out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  subroutine arguments
!  --------------------

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAXBEAMS, MAX_ATMOSWFS

!  Flag

      LOGICAL, INTENT(IN)   :: DO_PLANE_PARALLEL

!  Given layer index and Fourier number, Beam number (inputs)

      INTEGER, INTENT(IN)  :: N
      INTEGER, INTENT(IN)  :: FOURIER
      INTEGER, INTENT(IN)  :: IBEAM

!  Flux factor

      REAL(kind=dp), INTENT(IN)  :: FLUX_FACTOR

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)  :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  Stream value

      REAL(kind=dp), INTENT(IN)  :: STREAM_VALUE

!  Beam SZA cosine functions

      REAL(kind=dp), INTENT(IN)  :: PX0X(MAXBEAMS)

!  Linearization control

      INTEGER, INTENT(IN)  :: N_COLUMN_WFS

!  Average-secants

      REAL(kind=dp), INTENT(IN)  :: AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS )

!  OMEGA and ASYMM

      REAL(kind=dp), INTENT(IN)  :: OMEGA ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: ASYMM ( MAXLAYERS )

!  local matrices from eigenvalue computation

      REAL(kind=dp), INTENT(IN)  :: SAB(MAXLAYERS), DAB(MAXLAYERS)

!  Eigenvalues

      REAL(kind=dp), INTENT(IN)  :: EIGENVALUE(MAXLAYERS)

!  Auxiliary vectors

      REAL(kind=dp), INTENT(IN)  :: QSUMVEC(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: QDIFVEC(MAXLAYERS)
      REAL(kind=dp), INTENT(IN)  :: QVEC   (MAXLAYERS)

!  Linearizations

      REAL(kind=dp), INTENT(IN)  :: L_OMEGA       ( MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_ASYMM       ( MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_SAB         ( MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_DAB         ( MAXLAYERS, MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_EIGENVALUE  ( MAXLAYERS, MAX_ATMOSWFS )

      REAL(kind=dp), INTENT(IN)  :: LC_AVERAGE_SECANT ( MAXLAYERS, MAXBEAMS, MAX_ATMOSWFS )

!  Output variables
!  ----------------

!  Linearized Beam solution

      REAL(kind=dp), INTENT(INOUT) :: LC_WVEC(2,MAXLAYERS,MAX_ATMOSWFS)

!  help variables
!  --------------

      LOGICAL       :: DO_FIRST, DO_PSVAR
      INTEGER       :: Q
      REAL(kind=dp) :: TP, TM, SECBAR, XINV, F1
      REAL(kind=dp) :: QMAT, QFIN, QAUX, PI4
      REAL(kind=dp) :: L_SECBAR, L_INV_X0SQUARE
      REAL(kind=dp) :: L_OMEGA_ASYMM, L_QMAT, L_EIGEN_SQUARE
      REAL(kind=dp) :: L_QSUMVEC, L_QDIFVEC, L_HELP, L_QAUX, L_QVEC

!  Flux factor and other constants

      PI4 = 4.0d0 * dacos(-1.0d0)
      F1  = FLUX_FACTOR / PI4
      XINV = 1.0d0 / STREAM_VALUE

!  Only a solution if the layer is not below Cutoff.

      DO_FIRST = ( N .LE. LAYER_PIS_CUTOFF(IBEAM) )

!  Pseudo-spherical variation condition

      DO_PSVAR = ( .NOT. DO_PLANE_PARALLEL .AND. N.GT.1 )

!   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ THIS CODE MOVED to HERE

!  Skip this section if there is nothing varying
!    [ Zero the boundary layer values and start Part 2 ]

      IF ( .NOT. DO_FIRST) THEN
        DO Q = 1, N_COLUMN_WFS
          LC_WVEC(1,N,Q) = 0.0d0
          LC_WVEC(2,N,Q) = 0.0d0
        ENDDO
        RETURN
      ENDIF
!   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ END THIS CODE MOVED to HERE

!  solar zenith cosine for this layer

      SECBAR   = AVERAGE_SECANT(N,IBEAM)

!  set up driving vector (using saved results)
!  This must be done regardless of whether layer N is varying or not.

      QMAT = EIGENVALUE(N) * EIGENVALUE(N) - SECBAR * SECBAR
      QFIN = - SAB(N) * QVEC(N)
      QAUX = ( QFIN - QSUMVEC(N) ) / SECBAR

!  Linearization for layer N is in two parts:
!    1A. Linearization due to variations in Layer N itself (Profiles)
!    1B. Linearization due to columns    
!    2. Linearization due to variations in layers K < N (Profiles)

!  Part 1.
!  =======

! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! @@@@@@@@@@@  ABOVE CODE BLOCK MOVED FROM HERE @@@@@@@@@@@@@@@@
! @@@@ Bug implemented 04 June 2012, courtesy V. Natraj @@@@@@@
! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

!  For each varying parameter

      DO Q = 1, N_COLUMN_WFS

!  linearizations

        L_SECBAR       = LC_AVERAGE_SECANT(N,IBEAM,Q)
        L_OMEGA_ASYMM  = 3.0d0 *  &
            ( L_OMEGA(N,Q)*ASYMM(N) + OMEGA(N)*L_ASYMM(N,Q) )
        L_EIGEN_SQUARE = 2.0d0 * L_EIGENVALUE(N,Q) * EIGENVALUE(N)
        L_INV_X0SQUARE = 2.0d0 * L_SECBAR * SECBAR

!  Set up sum and differences for Beam source terms

        if ( fourier.eq.0) then
          TP = L_OMEGA(N,Q) + PX0X(IBEAM) * L_OMEGA_ASYMM
          TM = L_OMEGA(N,Q) - PX0X(IBEAM) * L_OMEGA_ASYMM
        Else if ( fourier .eq. 1 ) then
          TP = PX0X(IBEAM) * L_OMEGA_ASYMM
          TM = PX0X(IBEAM) * L_OMEGA_ASYMM
        ENDIF
        L_QSUMVEC = F1 * ( TP + TM ) * XINV
        L_QDIFVEC = F1 * ( TP - TM ) * XINV

!  Linearize the reduced problem

        L_HELP = - L_DAB(N,Q) * QSUMVEC(N) - DAB(N) * L_QSUMVEC
        L_QMAT = L_EIGEN_SQUARE - L_INV_X0SQUARE
        L_QVEC = L_HELP + L_QDIFVEC * SECBAR 
        IF ( DO_PSVAR ) THEN
          L_QVEC = L_QVEC + QDIFVEC(N) * L_SECBAR
        ENDIF
        L_QVEC = ( L_QVEC - QVEC(N) * L_QMAT ) / QMAT

!  Restore up and down solutions

        L_HELP = - L_SAB(N,Q) * QVEC(N) - SAB(N) * L_QVEC
        L_QAUX = ( L_HELP - L_QSUMVEC ) / SECBAR
        IF ( DO_PSVAR ) THEN
          L_QAUX = L_QAUX - QAUX * L_SECBAR / SECBAR
        ENDIF
        LC_WVEC(1,N,Q) = 0.5d0 * ( L_QVEC + L_QAUX )
        LC_WVEC(2,N,Q) = 0.5d0 * ( L_QVEC - L_QAUX )

!  End parameter loop

      ENDDO

!  debug
!        if (fourier.eq.0)write(*,'(2i4,1p3e24.12)')n,nv,
!     &         LC_WVEC(1,N,1),LC_WVEC(1,N,2)

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LC_BEAM_SOLUTION

!

SUBROUTINE TWOSTREAM_LC_BEAM_USERSOLUTION &
       ( MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS,        & ! Dimensions
         DO_UPWELLING, DO_DNWELLING, DO_USER_OBSGEOMS,               & ! Input !@@
         N_USER_STREAMS, N, FOURIER, IBEAM, N_COLUMN_WFS,            & ! Input
         FLUX_FACTOR, LAYER_PIS_CUTOFF, USER_STREAMS, STREAM_VALUE,  & ! Input
         PX11, ULP, OMEGA, ASYMM, L_OMEGA, L_ASYMM, W_HELP, LC_WVEC, & ! Input
         LC_U_WPOS2, LC_U_WNEG2 )                                      ! In/Out

      implicit none

!  precision

      INTEGER, PARAMETER :: dp     = KIND( 1.0D0 )

!  subroutine arguments
!  --------------------

!  Dimensions

      INTEGER, INTENT(IN)  :: MAXLAYERS, MAXBEAMS, MAX_USER_STREAMS, MAX_ATMOSWFS

!  Flags

      LOGICAL, INTENT(IN)  :: DO_UPWELLING, DO_DNWELLING

!   !@@ Observational Geometry flag !@@

      LOGICAL, INTENT(IN)  :: DO_USER_OBSGEOMS !@@

!  Numbers

      INTEGER, INTENT(IN)  :: N_USER_STREAMS

!  Given layer index and Fourier number, Beam number (inputs)

      INTEGER, INTENT(IN)  :: N
      INTEGER, INTENT(IN)  :: FOURIER
      INTEGER, INTENT(IN)  :: IBEAM

!  Linearization control

      INTEGER, INTENT(IN)  :: N_COLUMN_WFS

!  Flux factor

      REAL(kind=dp), INTENT(IN)  :: FLUX_FACTOR

!  Last layer to include Particular integral solution

      INTEGER, INTENT(IN)  :: LAYER_PIS_CUTOFF(MAXBEAMS)

!  Stream value and polynomial

      REAL(kind=dp), INTENT(IN)  :: STREAM_VALUE, PX11

!  Beam SZA cosines
!      REAL(kind=dp), INTENT(IN)  :: X0(MAXBEAMS)
!      REAL(kind=dp), INTENT(IN)  :: POX(MAXBEAMS)

!  OMEGA and ASYMM, + linearizations

      REAL(kind=dp), INTENT(IN)  :: OMEGA ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: ASYMM ( MAXLAYERS )
      REAL(kind=dp), INTENT(IN)  :: L_OMEGA ( MAXLAYERS,MAX_ATMOSWFS )
      REAL(kind=dp), INTENT(IN)  :: L_ASYMM ( MAXLAYERS,MAX_ATMOSWFS )

!  User streams

      REAL(kind=dp), INTENT(IN)  :: USER_STREAMS ( MAX_USER_STREAMS )
      REAL(kind=dp), INTENT(IN)  :: ULP          ( MAX_USER_STREAMS )

!  Saved help variables

      REAL(kind=dp), INTENT(IN)  :: W_HELP(0:1)

!  Linearized Beam solutions

      REAL(kind=dp), INTENT(IN)  :: LC_WVEC(2,MAXLAYERS,MAX_ATMOSWFS)

!  Subroutine output arguments
!  ---------------------------

!  Diffuse-term Particular beam solutions at user-defined angles

      REAL(kind=dp), INTENT(INOUT) :: LC_U_WPOS2(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)
      REAL(kind=dp), INTENT(INOUT) :: LC_U_WNEG2(MAX_USER_STREAMS,MAXLAYERS,MAX_ATMOSWFS)

!  Single-scatter Particular beam solutions at user-defined angles
!    NOT REQUIRED, MS_MODE only2 = Diffuse term contribution
!      REAL(kind=dp), INTENT(INOUT) :: LC_U_WPOS1(MAX_USER_STREAMS,MAX_ATMOSWFS)
!      REAL(kind=dp), INTENT(INOUT) :: LC_U_WNEG1(MAX_USER_STREAMS,MAX_ATMOSWFS)

!  Local variables
!  ---------------

      LOGICAL       :: DO_FIRST
      INTEGER       :: UM, Q
      REAL(kind=dp) :: POS2, F1, OMEGA_MOM, PI4, HMUS, HPX11
      REAL(kind=dp) :: L_OMEGA_MOM, l_h2(0:1), l_w(0:1)

!  No particular solution beyond the cutoff layer
!  ... Zero the user solutions and exit

!  Only a solution if the layer is not below Cutoff.

      DO_FIRST = ( N .LE. LAYER_PIS_CUTOFF(IBEAM) )

!  If no solution or no variation, zero output and go to Part 2

      IF ( .NOT. DO_FIRST ) THEN
        IF ( DO_USER_OBSGEOMS ) THEN
          IF ( DO_UPWELLING ) LC_U_WPOS2(IBEAM,N,1:N_COLUMN_WFS) = 0.0d0
          IF ( DO_DNWELLING ) LC_U_WNEG2(IBEAM,N,1:N_COLUMN_WFS) = 0.0d0
        ELSE
          DO UM = 1, N_USER_STREAMS
            IF ( DO_UPWELLING ) LC_U_WPOS2(UM,N,1:N_COLUMN_WFS) = 0.0d0
            IF ( DO_DNWELLING ) LC_U_WNEG2(UM,N,1:N_COLUMN_WFS) = 0.0d0
          ENDDO
        ENDIF
        RETURN
      ENDIF

!  set up numbers

      PI4 = 4.0d0 * dacos(-1.0d0)
      F1 = FLUX_FACTOR / PI4
      OMEGA_MOM  = 3.0d0 * OMEGA(N) * ASYMM(N)
      HMUS       = STREAM_VALUE * 0.5d0
      IF ( FOURIER.EQ.1 ) HPX11 = PX11 * 0.5d0

!  Start parameter loop

      DO Q = 1, N_COLUMN_WFS

!  basi! optical property variation

        L_OMEGA_MOM = L_OMEGA(N,Q)*ASYMM(N)+OMEGA(N)*L_ASYMM(N,Q)
        L_OMEGA_MOM = 3.0d0 * L_OMEGA_MOM

!  Eigenvector interpolation to user-defined angles
!  ------------------------------------------------

!  For each moment, do inner sum over computational angles
!  for the positive and negative eigenvectors

        if ( fourier.eq.0) then
          l_w(0)   = ( LC_WVEC(2,N,Q) + LC_WVEC(1,N,Q) ) * 0.5d0
          l_w(1)   = ( LC_WVEC(2,N,Q) - LC_WVEC(1,N,Q) ) * HMUS
          l_h2(0)  = l_w(0) * omega(n)  + w_help(0) * l_omega(n,q)
          l_h2(1)  = l_w(1) * omega_mom + w_help(1) * l_omega_mom
        else
          l_w(1)   = - ( LC_WVEC(2,N,Q) + LC_WVEC(1,N,Q) )* HPX11
          l_h2(1)  = l_w(1) * omega_mom + w_help(1) * l_omega_mom
        endif

!  Now sum over all harmonic contributions at each user-defined stream
!  Distinguish between upwelling and downwelling.
!   New: Observational Geometry, tie to the IB result.

        IF ( DO_UPWELLING ) THEN
          IF ( DO_USER_OBSGEOMS ) THEN
            if (fourier.eq.0 ) then
              pos2 = l_h2(0) + l_h2(1) * user_streams(IBEAM)
            else
              pos2 = l_h2(1) * ULP(IBEAM)
            endif
            LC_U_WPOS2(IBEAM,N,Q) = POS2
          ELSE
            DO UM = 1, N_USER_STREAMS
              if (fourier.eq.0 ) then
                pos2 = l_h2(0) + l_h2(1) * user_streams(UM)
              else
                pos2 = l_h2(1) * ULP(UM)
              endif
              LC_U_WPOS2(UM,N,Q) = POS2
            ENDDO
          ENDIF
        ENDIF

        IF ( DO_DNWELLING ) THEN
          IF ( DO_USER_OBSGEOMS ) THEN
            if (fourier.eq.0 ) then
              pos2 = l_h2(0) - l_h2(1) * user_streams(IBEAM)
            else
              pos2 = l_h2(1) * ULP(IBEAM)
            endif
            LC_U_WNEG2(IBEAM,N,Q) = POS2
          ELSE
            DO UM = 1, N_USER_STREAMS
              if (fourier.eq.0 ) then
                pos2 = l_h2(0) - l_h2(1) * user_streams(UM)
              else
                pos2 = l_h2(1) * ULP(UM)
              endif
              LC_U_WNEG2(UM,N,Q) = POS2
            ENDDO
          ENDIF
        ENDIF

!  End parameter loop

      enddo

!  Finish

      RETURN
END SUBROUTINE TWOSTREAM_LC_BEAM_USERSOLUTION

end module twostream_lc_solutions_m
